#af regression

#path for sync files for 37+287 genes

/work/cyu/poolseq/PPalign_output/ann_mt_pergene_sync
/mnt/spareHD_2/nu_287/sync

# === Nuclear ===
NU_SYNC_DIR=/mnt/spareHD_2/nu_287/sync
NU_BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
NU_OUTD=/mnt/spareHD_2/nu_287

# === Mitochondrial ===
MT_SYNC_DIR=/work/cyu/poolseq/PPalign_output/ann_mt_pergene_sync
MT_BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
MT_OUTD=/mnt/spareHD_2/mt_gene_tree

# === Tree file for mitochondrial PCoA ===
MT_TREE=/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile

# === Script path ===
SYNC2AF=/mnt/spareHD_2/nu_287/sync2af.py


#STEP 1. .sync → Allele Frequency long table

#Script: /mnt/spareHD_2/nu_287/sync2af.py
#→ converts each per-gene .sync to long-format AF table.

1) .sync → 等位频长表 + 元信息（核 287 基因）
nano /mnt/spareHD_2/nu_287/sync2af.py
#!/usr/bin/env python3
import sys, os, gzip, re
from collections import defaultdict

"""
用法：
  python sync2af.py <sync_dir> <bamlist_for_order> <out_af_long.tsv.gz> <out_meta.tsv.gz>

说明：
- sync_dir：像 /mnt/spareHD_2/nu_287/sync 这种目录（每基因一个 .sync）
  文件名如 aars2.ENSGACG00000019994.sync → gene = aars2（取第一个点前的 symbol）
- bamlist_for_order：核的 bamlist（顺序=种群列顺序）
  /mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
  会从路径抽样本名：.../10_THE_S10_subset.bam → pop=10_THE_S10
- 输出1（长表）：chr pos gene pop af depth
- 输出2（元信息）：chr pos gene major
"""

def open_any(path):
    return gzip.open(path, "rt") if path.endswith(".gz") else open(path, "rt")

def pops_from_bamlist(bamlist):
    pops=[]
    with open(bamlist) as f:
        for line in f:
            line=line.strip()
            if not line: continue
            base=os.path.basename(line)
            base=re.sub(r"_subset\.bam$","",base)
            pops.append(base)
    return pops

def parse_counts(cell):
    # "A:C:G:T:N:del"
    a=cell.split(":")
    A,C,G,T = map(int, a[:4])
    return A,C,G,T

def guess_gene_from_filename(fn):
    # aars2.ENSGACG00000019994.sync(.gz) → aars2
    fn=re.sub(r"\.sync(\.gz)?$","",fn)
    return fn.split(".")[0]

def main(sync_dir, bamlist, out_af, out_meta):
    pops = pops_from_bamlist(bamlist)
    if not pops:
        print("No pops from bamlist", file=sys.stderr); sys.exit(2)

    outA = gzip.open(out_af, "wt")
    outM = gzip.open(out_meta, "wt")
    outA.write("chr\tpos\tgene\tpop\taf\tdepth\n")
    outM.write("chr\tpos\tgene\tmajor\n")

    for fn in sorted(os.listdir(sync_dir)):
        if not (fn.endswith(".sync") or fn.endswith(".sync.gz")): 
            continue
        gene = guess_gene_from_filename(fn)
        with open_any(os.path.join(sync_dir, fn)) as fp:
            for line in fp:
                if not line.strip(): continue
                toks=line.split()
                if len(toks) < 3+len(pops): 
                    continue
                chr_, pos, ref = toks[0], int(toks[1]), toks[2]
                cells = toks[3:3+len(pops)]

                # 全群体合并确定全局主等位
                tot={'A':0,'C':0,'G':0,'T':0}
                per=[]
                for i, pop in enumerate(pops):
                    A,C,G,T = parse_counts(cells[i])
                    tot['A']+=A; tot['C']+=C; tot['G']+=G; tot['T']+=T
                    per.append((pop,A,C,G,T))
                major = max(tot.items(), key=lambda x:x[1])[0]
                if tot[major]==0: 
                    continue

                outM.write(f"{chr_}\t{pos}\t{gene}\t{major}\n")
                for pop,A,C,G,T in per:
                    depth=A+C+G+T
                    if depth==0: 
                        continue
                    maj={'A':A,'C':C,'G':G,'T':T}[major]
                    af=maj/depth
                    outA.write(f"{chr_}\t{pos}\t{gene}\t{pop}\t{af:.6f}\t{depth}\n")

    outA.close(); outM.close()

if __name__=="__main__":
    if len(sys.argv)!=5:
        print(__doc__, file=sys.stderr); sys.exit(1)
    main(*sys.argv[1:])


SYNC_DIR=/mnt/spareHD_2/nu_287/sync
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
OUT_AF=/mnt/spareHD_2/nu_287/af_long.tsv.gz
OUT_META=/mnt/spareHD_2/nu_287/snp_meta.tsv.gz

python /mnt/spareHD_2/nu_287/sync2af.py "$SYNC_DIR" "$BAMLIST" "$OUT_AF" "$OUT_META"


SYNC_DIR=/work/cyu/poolseq/PPalign_output/ann_mt_pergene_sync
BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
OUT_AF=/mnt/spareHD_2/mt_gene_tree/mt_af_long.tsv.gz
OUT_META=/mnt/spareHD_2/mt_gene_tree/mt_snp_meta.tsv.gz

python /mnt/spareHD_2/nu_287/sync2af.py "$SYNC_DIR" "$BAMLIST" "$OUT_AF" "$OUT_META"



# 目录与清单（按你已有路径）
SYNC_DIR=/mnt/spareHD_2/nu_287/sync
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
OUT_AF=/mnt/spareHD_2/nu_287/af_long.tsv.gz
OUT_META=/mnt/spareHD_2/nu_287/snp_meta.tsv.gz

# 若你已保存了这个脚本，直接运行；若没有，把它保存到下面的路径再跑
python /mnt/spareHD_2/nu_287/sync2af.py "$SYNC_DIR" "$BAMLIST" "$OUT_AF" "$OUT_META"



# === 路径（按你现有目录已填好）===
SYNC_DIR=/mnt/spareHD_2/nu_287/sync
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
PY_SYNC2AF=/mnt/spareHD_2/nu_287/sync2af.py          # 我之前给你的脚本应保存在这里
OUTD=/mnt/spareHD_2/nu_287
MT_TREE=/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile

# 0) 先生成核 AF 长表（若未生成）
if [ ! -s "$OUTD/af_long.tsv.gz" ]; then
  if [ ! -s "$PY_SYNC2AF" ]; then
    echo "ERROR: 找不到 $PY_SYNC2AF（sync2af.py）。请先把我之前给你的 Python 脚本保存到这个路径。" >&2
    exit 2
  fi
  python "$PY_SYNC2AF" "$SYNC_DIR" "$BAMLIST" "$OUTD/af_long.tsv.gz" "$OUTD/snp_meta.tsv.gz"
fi

# 1) 用 R 一次性生成 af_matrix.tsv.gz + covariates.tsv
Rscript - <<'RS'
suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(tidyr); library(ape)
})

af_long <- "/mnt/spareHD_2/nu_287/af_long.tsv.gz"
out_mat <- "/mnt/spareHD_2/nu_287/af_matrix.tsv.gz"
mt_tree <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_cov <- "/mnt/spareHD_2/nu_287/covariates.tsv"

# --- 核 AF 长表 -> 宽矩阵 ---
AF <- fread(af_long)   # 需要列: chr pos gene pop af depth
stopifnot(all(c("chr","pos","gene","pop","af") %in% names(AF)))
AF <- AF %>% mutate(snp=paste(chr,pos,gene,sep=":")) %>%
             select(pop,snp,af) %>% distinct()

MAT <- AF %>% tidyr::pivot_wider(names_from=snp, values_from=af)
MAT <- as.data.frame(MAT); rownames(MAT) <- MAT$pop; MAT$pop <- NULL

# 列均值填补 NA
for(j in seq_len(ncol(MAT))){
  v <- MAT[[j]]; if(anyNA(v)) MAT[[j]][is.na(v)] <- mean(v, na.rm=TRUE)
}
# 写出矩阵
fwrite(MAT %>% tibble::rownames_to_column("pop"), out_mat, sep="\t")

# --- 核 PCA（nucPC1-2）---
pca <- prcomp(MAT, center=TRUE, scale.=TRUE)
nucPC <- data.frame(pop=rownames(pca$x), nucPC1=pca$x[,1], nucPC2=pca$x[,2])

# --- mt 树 → cophenetic 距离 → PCoA（mitoPC1-3）---
tr <- read.tree(mt_tree)
D  <- cophenetic(tr)
common <- intersect(rownames(MAT), rownames(D))
if(length(common)<3) stop("Overlapping pops < 3 between nuclear AF and mt tree.")
D <- D[common, common, drop=FALSE]
pco <- cmdscale(D, k=3)
mitoPC <- data.frame(pop=rownames(pco),
                     mitoPC1=pco[,1], mitoPC2=pco[,2], mitoPC3=pco[,3])

# --- 区域标签（按你既定分组）---
cov_region <- data.frame(pop = rownames(MAT)) %>%
  mutate(region = case_when(
    grepl("^(FG|LG|SR|SL|TL|WB|WT|WK|LB)", pop) ~ "Alaska",
    grepl("^(SWA|THE|JOE|BEA|MUC|PYE|ROS|AMO|BOOT|ECHO|LAW|GOS|ROB)", pop) ~ "BC",
    grepl("^(RS|SAY)", pop) ~ "Marine",
    grepl("^(PACH|FRED|SC|CH)", pop) ~ "Recent",
    TRUE ~ "Other"
  ))

# --- 合并并写出 covariates ---
covars <- nucPC %>% inner_join(mitoPC, by="pop") %>% inner_join(cov_region, by="pop")
fwrite(covars, out_cov, sep="\t")
cat("[ok] wrote:\n  ", out_mat, "\n  ", out_cov, "\n")
RS

# 2) 快速检查
ls -lh "$OUTD/af_long.tsv.gz" "$OUTD/af_matrix.tsv.gz" "$OUTD/covariates.tsv"



Rscript - <<'RS'
suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(tidyr); library(ape)
})

af_mat_gz <- "/mnt/spareHD_2/nu_287/af_matrix.tsv.gz"
mt_tree   <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_cov   <- "/mnt/spareHD_2/nu_287/covariates.tsv"

# ---------- 读核 AF 宽表 ----------
MAT0 <- fread(cmd = paste("zcat", shQuote(af_mat_gz)))
stopifnot("pop" %in% names(MAT0))

# 保存原始样本名，并标准化为“核心名”：
# 规则：拆分 '_'，若第一个是数字则取第二段；末尾若有 'subset' 或 'S\d+' 等后缀去掉
normalize_pop <- function(x){
  parts <- strsplit(x, "_", fixed = TRUE)
  vapply(parts, function(p){
    if (length(p)==1) return(p[1])
    # 去掉末尾“subset”等
    p <- p[ p!="subset" & p!="" ]
    if (length(p)>=2 && grepl("^[0-9]+$", p[1])) core <- p[2] else core <- p[1]
    # 再把像 'S1','S10' 这类末段去掉
    core <- gsub("^(.*?)(?:_S[0-9]+)?$", "\\1", core, perl=TRUE)
    toupper(core)
  }, character(1))
}

MAT0$core <- normalize_pop(MAT0$pop)

# 若同一 core 名出现多次，先聚合为均值
num_cols <- setdiff(names(MAT0), c("pop","core"))
MAT0[, (num_cols) := lapply(.SD, as.numeric), .SDcols = num_cols]
MAT_core <- MAT0 %>% group_by(core) %>% summarise(across(all_of(num_cols), ~ mean(.x, na.rm=TRUE))) %>% ungroup()

# 把 core 设为行名
MAT <- as.data.frame(MAT_core)
rownames(MAT) <- MAT$core
MAT$core <- NULL

# 丢全 NA 列
all_na <- names(MAT)[colSums(!is.na(MAT))==0]
if(length(all_na)) MAT[, all_na] <- NULL

# 列均值填补 NA
for(j in seq_len(ncol(MAT))){
  v <- MAT[[j]]
  if(anyNA(v)){
    m <- mean(v, na.rm=TRUE)
    if(is.finite(m)) MAT[[j]][is.na(MAT[[j]])] <- m
  }
}

# 丢零方差列
sds <- sapply(MAT, function(x) sd(x, na.rm=TRUE))
const_cols <- names(MAT)[!is.finite(sds) | sds==0]
if(length(const_cols)) MAT[, const_cols] <- NULL
cat("[info] SNP columns kept:", ncol(MAT), " removed:", length(all_na)+length(const_cols), "\n")

# ---------- 核 PCA ----------
if(ncol(MAT) < 2) stop("Too few informative SNP columns after filtering.")
pca <- prcomp(as.matrix(MAT), center=TRUE, scale.=TRUE)
nucPC <- data.frame(pop = rownames(pca$x),
                    nucPC1 = pca$x[,1],
                    nucPC2 = pca$x[,2])

# ---------- mt 树 → cophenetic → PCoA ----------
tr <- read.tree(mt_tree)
D  <- cophenetic(tr)
tree_pops <- rownames(D)

# 名字交集（以标准化后的核名为准）
common <- intersect(nucPC$pop, tree_pops)
cat("[match] AF pops:", length(unique(nucPC$pop)),
    " | tree tips:", length(tree_pops),
    " | intersection:", length(common), "\n")

if(length(common) < 3){
  cat("[WARN] Overlap < 3. Unmatched (AF-only):", paste(setdiff(nucPC$pop, tree_pops), collapse=","), "\n")
  cat("[WARN] Unmatched (tree-only):", paste(setdiff(tree_pops, nucPC$pop), collapse=","), "\n")
  stop("Need >=3 overlapping pops for PCoA.")
}

# PCoA 仅对交集
D2 <- D[common, common, drop=FALSE]
pco <- cmdscale(D2, k=3)
mitoPC <- data.frame(pop = rownames(pco),
                     mitoPC1 = pco[,1], mitoPC2 = pco[,2], mitoPC3 = pco[,3])

nucPC2 <- nucPC %>% filter(pop %in% common)

# ---------- 区域标签 ----------
cov_region <- data.frame(pop = common) %>%
  mutate(region = case_when(
    grepl("^(FG|LG|SR|SL|TL|WB|WT|WK|LB)$", pop) ~ "Alaska",
    grepl("^(SWA|THE|JOE|BEA|MUC|PYE|ROS|AMO|BOOT|ECHO|LAW|GOS|ROB)$", pop) ~ "BC",
    grepl("^(RS|SAY)$", pop) ~ "Marine",
    grepl("^(PACH|FRED|SC|CH)$", pop) ~ "Recent",
    TRUE ~ "Other"
  ))

# ---------- 合并并写出 ----------
covars <- nucPC2 %>% inner_join(mitoPC, by="pop") %>% inner_join(cov_region, by="pop")
fwrite(covars, out_cov, sep="\t")
cat("[ok] wrote:", out_cov, "  (n_pops=", nrow(covars), ")\n")

# 打印未匹配清单（方便你核查样本名）
af_only <- setdiff(nucPC$pop, tree_pops)
tree_only <- setdiff(tree_pops, nucPC$pop)
if(length(af_only))  cat("[AF-only names]", paste(af_only, collapse=", "), "\n")
if(length(tree_only)) cat("[Tree-only names]", paste(tree_only, collapse=", "), "\n")
RS

# 查看结果
ls -lh /mnt/spareHD_2/nu_287/covariates.tsv




#tree pca
#!/usr/bin/env Rscript
# Construct covariate table for Step 3 association model
#   - Nuclear PCs from allele frequencies (population structure)
#   - Mito PCs from mt tree (haplotype structure)
#   - Tree PCs from nuclear phylogeny (neutral background)
# Output: covariates.treePC.tsv

library(ape)

# 读你刚 scp 上去的 NJ 树（用 unrooted 那个就行）
tr0 <- read.tree("/work/cyu/unrooted_NJ_tree.tree")

# 你要保留的 27 个种群名字（就是你一直用的那一套）
pops27 <- c(
  "THE","AMO","SWA","JOE","BEA","MUC","FRED","PACH","LB","SAY",
  "CH","RS","SC","SL","WK","WT","TL","SR","LG","FG","WB",
  "PYE","ROB","LAW","GOS","ECHO","BOOT"
)

# 看看树里有哪些 tip
tree_tips <- sort(tr0$tip.label)
cat("tree tips:\n"); print(tree_tips)

# 找出“树里有但不在 27 个名单里的” → 就是多余的
extra <- setdiff(tree_tips, pops27)
cat("extra tips to drop:\n"); print(extra)
# 这里你已经看到是 "ROS"

# 删掉 ROS
tr <- drop.tip(tr0, extra)

# 存一份干净的 27 种群 neutral 树
write.tree(tr, file = "/work/cyu/unrooted_NJ_tree_27.tree")


library(ape)

tr <- read.tree("/work/cyu/unrooted_NJ_tree_27.tree")

# 1) 树 → 成对距离矩阵
D <- cophenetic(tr)   # 27 x 27，没有 NA 就对了

# 2) 距离矩阵 → PCoA / MDS，取前三个轴
pco <- cmdscale(D, k = 3)

treePC <- data.frame(
  pop     = rownames(pco),
  treePC1 = pco[, 1],
  treePC2 = pco[, 2],
  treePC3 = pco[, 3]
)

# 存到一个表里，后面当 covariate 用
out_treepc <- "/mnt/spareHD_2/nu_287/treePC_from_NJ.tsv"
write.table(treePC, out_treepc,
            sep = "\t", quote = FALSE, row.names = FALSE)
cat("wrote tree PCs to:", out_treepc, "\n")

library(data.table)
library(dplyr)

cov_path   <- "/mnt/spareHD_2/nu_287/covariates.tsv"
treepc_path <- "/mnt/spareHD_2/nu_287/treePC_from_NJ.tsv"
out_cov2   <- "/mnt/spareHD_2/nu_287/covariates.treePC.tsv"

# 1) 读旧的 covariates（里面有 mitoPC 和 region）
COV <- fread(cov_path)

# 2) 读我们刚算的 treePC
TPC <- fread(treepc_path)

# 3) 把旧的 nucPC1/2/3 去掉（只保留 pop / mitoPC* / region）
COV2 <- COV %>%
  select(-starts_with("nucPC"))

# 4) 合并进 treePC（按 pop 匹配）
COV3 <- COV2 %>%
  inner_join(TPC, by = "pop")

# 看一眼列名
print(colnames(COV3))

# 5) 写出新的 covariates
fwrite(COV3, out_cov2, sep = "\t")
cat("new covariates with treePC written to:", out_cov2, "\n")



suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(tidyr); library(ape)
})

# === Paths ===
af_mat_gz <- "/mnt/spareHD_2/nu_287/af_matrix.tsv.gz"
mt_tree   <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_cov   <- "/mnt/spareHD_2/nu_287/covariates.treePC.tsv"

# === 1. Read nuclear AF matrix ===
MAT0 <- fread(cmd=paste("zcat",shQuote(af_mat_gz)))
stopifnot("pop" %in% names(MAT0))

# simplify pop names (10_THE_S10 → THE)
normalize_pop <- function(x){
  parts <- strsplit(x,"_")
  vapply(parts,function(p){
    core <- if(length(p)>=2 && grepl("^[0-9]+$",p[1])) p[2] else p[1]
    core <- gsub("^(.*?)(_S[0-9]+)?$","\\1",core)
    toupper(core)
  },character(1))
}
MAT0$core <- normalize_pop(MAT0$pop)
MAT_core <- MAT0 %>%
  group_by(core) %>%
  summarise(across(where(is.numeric),mean,na.rm=TRUE))
MAT <- as.data.frame(MAT_core); rownames(MAT)<-MAT$core; MAT$core<-NULL

# fill NA with column mean
for(j in seq_len(ncol(MAT))){
  v<-MAT[[j]]; if(anyNA(v)) MAT[[j]][is.na(v)]<-mean(v,na.rm=TRUE)
}
# remove constant columns
MAT <- MAT[,apply(MAT,2,sd,na.rm=TRUE)>0]

# === 2. Nuclear PCA ===
pca <- prcomp(MAT, center=TRUE, scale.=TRUE)
nucPC <- data.frame(pop=rownames(pca$x),
                    nucPC1=pca$x[,1], nucPC2=pca$x[,2], nucPC3=pca$x[,3])

# === 3. Mitochondrial tree PCoA ===
tr <- read.tree(mt_tree)
D  <- cophenetic(tr)
common <- intersect(rownames(MAT), rownames(D))
D2 <- D[common, common]
pco <- cmdscale(D2, k=3)
mitoPC <- data.frame(pop=rownames(pco),
                     mitoPC1=pco[,1], mitoPC2=pco[,2], mitoPC3=pco[,3])

# === 4. Region labels ===
cov_region <- data.frame(pop=common) %>%
  mutate(region=case_when(
    grepl("^(FG|LG|SR|SL|TL|WB|WT|WK|LB)$",pop) ~ "Alaska",
    grepl("^(SWA|THE|JOE|BEA|MUC|PYE|ROS|AMO|BOOT|ECHO|LAW|GOS|ROB)$",pop) ~ "BC",
    grepl("^(RS|SAY)$",pop) ~ "Marine",
    grepl("^(PACH|FRED|SC|CH)$",pop) ~ "Recent",
    TRUE ~ "Other"
  ))

# === 5. Merge ===
covars <- nucPC %>%
  inner_join(mitoPC, by="pop") %>%
  inner_join(cov_region, by="pop")

fwrite(covars, out_cov, sep="\t")
cat("[ok] wrote:", out_cov, " (n_pops=", nrow(covars), ")\n")


生成/mnt/spareHD_2/nu_287/covariates.treePC.tsv



#Step 3 : Per-SNP Association Model
#!/usr/bin/env Rscript
# Per-SNP association: allele frequency vs mitoPC + treePC
# Model: AF_pop ~ mitoPC1 + mitoPC2 + treePC1 + treePC2

suppressPackageStartupMessages({
  library(data.table); library(dplyr)
})

args <- commandArgs(trailingOnly=TRUE)
if(length(args)!=3){
  cat("Usage: Rscript run_assoc_perSNP_haplo.R <af_long.tsv.gz> <covariates.tsv> <out_prefix>\n")
  quit("no")
}

af_file <- args[1]; cov_file <- args[2]; out_prefix <- args[3]
cat("[input]\n AF :",af_file,"\n COV:",cov_file,"\n OUT:",out_prefix,"\n")

AF  <- fread(cmd=paste("zcat",shQuote(af_file)))
COV <- fread(cov_file)

# simplify pop name to match covariates
normalize_pop <- function(x){
  gsub("^(\\d+_)?([A-Za-z]+)(_S\\d+)?$", "\\2", x)
}
AF$pop <- toupper(normalize_pop(AF$pop))

dat <- inner_join(AF, COV, by="pop")
cat("[info] N rows after merge:",nrow(dat),"\n")

# run regression per SNP
genes <- unique(dat$gene)
out <- list()

for(g in genes){
  sub <- dat[dat$gene==g,]
  snps <- unique(paste(sub$chr,sub$pos,sep=":"))
  for(snp in snps){
    tmp <- sub[paste(chr,pos,sep=":")==snp,]
    if(nrow(tmp)<5) next
    fit <- try(lm(af ~ mitoPC1 + mitoPC2 + treePC1 + treePC2, data=tmp), silent=TRUE)
    if(inherits(fit,"try-error")) next
    summ <- summary(fit)
    pvals <- coef(summ)[,4]
    R2 <- summ$r.squared
    out[[length(out)+1]] <- data.frame(
      chr=tmp$chr[1],
      pos=tmp$pos[1],
      gene=tmp$gene[1],
      p_mitoPC1=pvals["mitoPC1"],
      p_mitoPC2=pvals["mitoPC2"],
      R2=R2,
      n=nrow(tmp)
    )
  }
}

RES <- bind_rows(out)
RES$BH_mitoPC1 <- p.adjust(RES$p_mitoPC1, method="BH")
RES$BH_mitoPC2 <- p.adjust(RES$p_mitoPC2, method="BH")
out_file <- paste0(out_prefix,"_perSNP.tsv.gz")
fwrite(RES, out_file, sep="\t")
cat("[ok] wrote:", out_file, "  (SNPs:", nrow(RES), ")\n")


Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo.R \
  /mnt/spareHD_2/nu_287/af_long.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.tsv \
  /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo

/mnt/spareHD_2/nu_287/

_assoc_perGene_sigCount.tsv.gz
_assoc_perSNP_haplo_perSNP.tsv.gz

#resid  /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo_resid.R

#!/usr/bin/env Rscript
# ------------------------------------------------------------
# Per-SNP association (residualized)
# Control for treePC1, treePC2 before regression
# Model: AF_pop ~ mitoPC1_resid + mitoPC2_resid
# ------------------------------------------------------------

suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
})

args <- commandArgs(trailingOnly=TRUE)
if (length(args) != 3) {
  cat("Usage: Rscript run_assoc_perSNP_haplo_resid.R <af_long.tsv.gz> <covariates.tsv> <out_prefix>\n")
  quit("no")
}

af_file  <- args[1]
cov_file <- args[2]
out_pref <- args[3]

cat("[input]\n  AF :", af_file, "\n  COV:", cov_file, "\n  OUT:", out_pref, "\n")

AF  <- fread(cmd=paste("zcat", shQuote(af_file)))
COV <- fread(cov_file)

# ==== Residualize mitoPCs against treePCs ====
r1 <- lm(mitoPC1 ~ treePC1 + treePC2, data=COV)
r2 <- lm(mitoPC2 ~ treePC1 + treePC2, data=COV)
COV$mitoPC1_resid <- resid(r1)
COV$mitoPC2_resid <- resid(r2)

cat("[resid] mitoPC1 vs treePC → cor =", round(cor(COV$mitoPC1, COV$treePC1),3),
    ", mitoPC2 vs treePC → cor =", round(cor(COV$mitoPC2, COV$treePC1),3), "\n")

out_cov <- paste0(out_pref, "_covariates_resid.tsv")
fwrite(COV, out_cov, sep="\t")
cat("[ok] wrote:", out_cov, "\n")

# ==== Merge AF and covariates ====
normalize_pop <- function(x) {
  gsub("^(\\d+_)?([A-Za-z]+)(_S\\d+)?$", "\\2", x)
}
AF$pop <- toupper(normalize_pop(AF$pop))
DAT <- inner_join(AF, COV, by="pop")

cat("[info] merged rows:", nrow(DAT), "\n")

# ==== Regression per SNP ====
genes <- unique(DAT$gene)
out <- list()

pb <- txtProgressBar(min=0, max=length(genes), style=3)
for (i in seq_along(genes)) {
  g <- genes[i]
  sub <- DAT[DAT$gene == g, ]
  snps <- unique(paste(sub$chr, sub$pos, sep=":"))
  for (snp in snps) {
    tmp <- sub[paste(chr,pos,sep=":") == snp, ]
    if (nrow(tmp) < 5) next
    fit <- try(lm(af ~ mitoPC1_resid + mitoPC2_resid, data=tmp), silent=TRUE)
    if (inherits(fit,"try-error")) next
    summ <- summary(fit)
    pvals <- coef(summ)[,4]
    R2 <- summ$r.squared
    out[[length(out)+1]] <- data.frame(
      chr=tmp$chr[1],
      pos=tmp$pos[1],
      gene=tmp$gene[1],
      p_mitoPC1=pvals["mitoPC1_resid"],
      p_mitoPC2=pvals["mitoPC2_resid"],
      R2=R2,
      n=nrow(tmp)
    )
  }
  setTxtProgressBar(pb, i)
}
close(pb)

RES <- bind_rows(out)
RES$BH_mitoPC1 <- p.adjust(RES$p_mitoPC1, method="BH")
RES$BH_mitoPC2 <- p.adjust(RES$p_mitoPC2, method="BH")

out_file <- paste0(out_pref, "_perSNP_resid.tsv.gz")
fwrite(RES, out_file, sep="\t")
cat("[ok] wrote:", out_file, " (", nrow(RES), " SNPs)\n")


Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo_resid.R \
  /mnt/spareHD_2/nu_287/af_long.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.tsv \
  /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo

[resid] mitoPC1 vs treePC → cor = -0.083 , mitoPC2 vs treePC → cor = 0.11




/mnt/spareHD_2/nu_287/

原始 per-SNP 回归（含 treePC）
│
├──▶ _assoc_perSNP_haplo_perSNP.tsv.gz        ← 全 SNP 原始结果
│
└──▶ 残差化 mitoPC1/2（去掉 tree 影响）
      │
      ├──▶ _assoc_perSNP_haplo_perSNP_resid.tsv.gz   ← 全 SNP 残差结果
      │
      └──▶ _assoc_perSNP_haplo_perSNP_resid_sig.tsv.gz ← 仅保留显著 SNP (FDR<0.05)

zcat /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP_resid_sig.tsv.gz \
  | awk 'NR>1 {print $3}' | sort | uniq -c | sort -k1,1nr | head
80  eprs
76  mrpl49
53  iars2
46  vars2
44  iars
44  vars
38  aars2
37  ndufs1
36  cep89
34  aifm1



#check lamda before resid
#!/usr/bin/env Rscript
# Calculate genomic inflation factor λ for mitoPC1 and mitoPC2 (original model)

suppressPackageStartupMessages(library(data.table))

# --- Input file (non-residual model) ---
file <- "/mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP.tsv.gz"

cat("[input] ", file, "\n")

# --- Read data ---
df <- fread(cmd = paste("zcat", shQuote(file)))
df <- df[is.finite(p_mitoPC1) & is.finite(p_mitoPC2)]

# --- Calculate chi² for each test (df=1) ---
df$chi1 <- qchisq(1 - df$p_mitoPC1, 1)
df$chi2 <- qchisq(1 - df$p_mitoPC2, 1)

# --- Expected median chi² under null ---
median_null <- qchisq(0.5, 1)

# --- Inflation factors ---
lambda1 <- median(df$chi1, na.rm=TRUE) / median_null
lambda2 <- median(df$chi2, na.rm=TRUE) / median_null

cat("λ_mitoPC1 =", round(lambda1, 3),
    "\nλ_mitoPC2 =", round(lambda2, 3), "\n")


#!/usr/bin/env Rscript check_lambda_resid.R
# Calculate genomic inflation factor λ for mitoPC1/2 (residualized model)

suppressPackageStartupMessages(library(data.table))

file <- "/mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP_resid.tsv.gz"

cat("[input] ", file, "\n")

df <- fread(cmd = paste("zcat", shQuote(file)))
df <- df[is.finite(p_mitoPC1) & is.finite(p_mitoPC2)]

df$chi1 <- qchisq(1 - df$p_mitoPC1, 1)
df$chi2 <- qchisq(1 - df$p_mitoPC2, 1)

median_null <- qchisq(0.5, 1)
lambda1 <- median(df$chi1, na.rm=TRUE) / median_null
lambda2 <- median(df$chi2, na.rm=TRUE) / median_null

cat("λ_mitoPC1_resid =", round(lambda1, 3),
    "\nλ_mitoPC2_resid =", round(lambda2, 3), "\n")





#mtpc
# 载入系统发育树
library(ape)
tr <- read.tree("/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile")
D  <- cophenetic(tr)

# 运行 PCoA
pco <- cmdscale(D, k=3, eig=TRUE)

# 输出方差解释比例
explained <- 100 * pco$eig / sum(pco$eig)
explained[1:5]
cat("Variance explained by mitoPC1-3:\n")
cat(sprintf("  PC1: %.2f%%\n  PC2: %.2f%%\n  PC3: %.2f%%\n",
            explained[1], explained[2], explained[3]))











#检查多少个snp 类别归类
library(data.table)

# ---- inputs ----
sig   <- fread(cmd="zcat /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP_resid_sig.tsv.gz")
annot <- fread("/mnt/spareHD_2/oxphos_codeml_ready/09_codeml_sites_models/codeml_sites_summary.merged.corefixed.tsv")

# ---- normalize gene ----
sig[,   gene := tolower(gsub("[[:space:]]+", "", gene))]
annot[, gene := tolower(gsub("[[:space:]]+", "", gene))]

# ---- collapse annotation (1 row / gene) ----
annot1 <- unique(annot[, .(gene, role, complex, core_status)])

# ---- merge ----
m <- merge(sig, annot1, by="gene", all.x=TRUE)

# ---- SUBUNIT ONLY ----
ms <- m[role == "subunit"]

# ---- summaries ----
by_complex <- ms[, .(n_gene=uniqueN(gene), n_sigSNPs=.N), by=complex]
by_core    <- ms[!is.na(core_status),
                 .(n_gene=uniqueN(gene), n_sigSNPs=.N),
                 by=core_status]

print(by_complex)
print(by_core)
cat("subunit genes:", uniqueN(ms$gene), "\n")
cat("subunit SNPs :", nrow(ms), "\n")




/mnt/spareHD_2/nu_287/oldsig_subunit_SNP_rows_plusSI.tsv
oldsig_subunit_gene_table.tsv



(r_env) cyu@stickleback:/mnt/spareHD_2/nu_287$ Rscript 1.R
There were 50 or more warnings (use warnings() to see the first 50)
  K lambda_PC1 lambda_PC2 median_p_PC1 median_p_PC2 n_snps
1 2  0.1289938   3.001671    0.8085882    0.2425746 228703
2 3  0.1147295   3.017718    0.8192875    0.2413194 228703




#72 subunit

[λ comparison]
λ_mitoPC1_raw   = 0.120
λ_mitoPC2_raw   = 2.792
λ_mitoPC1_resid = 0.129
λ_mitoPC2_resid = 3.002



Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo_resid.R \
  /mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.tsv \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit

Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo.R \
  /mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.tsv \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/Q1RAW_on_AF72
[input]
  AF  : /mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz 
  COV : /mnt/spareHD_2/nu_287/covariates.treePC.tsv 
  OUT : /mnt/spareHD_2/nu_287/_assoc72_subunit/Q1RAW_on_AF72 
[using] covariates: mitoPC1 mitoPC2 treePC1 treePC2
[info] N rows after merge: 1155546 
There were 50 or more warnings (use warnings() to see the first 50)
[done] total SNP tested: 42807 
[ok] wrote: /mnt/spareHD_2/nu_287/_assoc72_subunit/Q1RAW_on_AF72_perSNP.tsv.gz 




cat > plot_assoc72_gene_equalwidth_manhattan_resid.R <<'RSCRIPT'
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(ggplot2)
})

infile <- "/mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit_perSNP_resid.tsv.gz"
outdir <- "/mnt/spareHD_2/nu_287/_assoc72_subunit"
stopifnot(file.exists(infile))

df <- fread(infile)

need <- c("gene","pos","p_mitoPC1","p_mitoPC2","BH_mitoPC1","BH_mitoPC2")
miss <- setdiff(need, names(df))
if (length(miss) > 0) stop("Missing columns: ", paste(miss, collapse=", "))

# order genes by genomic position (min pos); you can replace with any custom order list later
gene_order <- df %>%
  filter(!is.na(gene), !is.na(pos)) %>%
  group_by(gene) %>%
  summarise(min_pos = min(pos, na.rm=TRUE), .groups="drop") %>%
  arrange(min_pos, gene) %>%
  pull(gene)

df <- df %>%
  filter(!is.na(gene), !is.na(pos)) %>%
  mutate(gene = factor(gene, levels = gene_order))

# Equal-width x within each gene: rank SNPs by position and rescale to [0,1)
df <- df %>%
  group_by(gene) %>%
  arrange(pos, .by_group = TRUE) %>%
  mutate(
    n_in_gene = n(),
    # position within gene block: 0..1, with slight jitter to reduce overplotting
    x_within = ifelse(n_in_gene > 1, (row_number() - 1) / (n_in_gene - 1), 0.5),
    x_within = pmin(1, pmax(0, x_within + runif(n(), -0.012, 0.012)))
  ) %>%
  ungroup()

# Map each gene to an integer block on x-axis: gene_index + x_within
gene_index_tbl <- tibble(gene = factor(gene_order, levels=gene_order),
                         gene_index = seq_along(gene_order))

df <- df %>%
  left_join(gene_index_tbl, by="gene") %>%
  mutate(x = gene_index + x_within)

p_line <- -log10(0.05)

plot_one <- function(pcol, bhcol, title, outfile) {
  d <- df %>%
    mutate(
      pval = .data[[pcol]],
      qval = .data[[bhcol]],
      logp = -log10(pval),
      is_hit = (!is.na(qval) & qval < 0.05)
    )

  g <- ggplot(d, aes(x = x, y = logp, color = gene)) +
    geom_point(size = 0.7, alpha = 0.85) +
    geom_hline(yintercept = p_line, linetype = "dashed", color = "red") +
    labs(
      title = title,
      x = "OXPHOS subunit gene (equal-width blocks)",
      y = expression(-log[10](p))
    ) +
    scale_x_continuous(
      breaks = gene_index_tbl$gene_index + 0.5,
      labels = as.character(gene_index_tbl$gene),
      expand = expansion(mult = 0.01)
    ) +
    theme_bw(base_size = 12) +
    theme(
      legend.position = "none",
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.text.x = element_text(angle = 60, hjust = 1, vjust = 1)
    )

  # outline BH hits
  if (any(d$is_hit, na.rm=TRUE)) {
    g <- g + geom_point(
      data = d %>% filter(is_hit),
      aes(x = x, y = logp),
      inherit.aes = FALSE,
      shape = 21, stroke = 0.4, size = 1.6, fill = NA, color = "black"
    )
  }

  ggsave(outfile, g, width = 18, height = 5.5, dpi = 300)
  message("[DONE] wrote: ", outfile)
}

plot_one(
  "p_mitoPC1", "BH_mitoPC1",
  "assoc72 subunits (resid): mitoPC1 equal-width gene-Manhattan (BH<0.05 outlined)",
  file.path(outdir, "assoc72_resid_mitoPC1_geneEqualWidth_manhattan.png")
)

plot_one(
  "p_mitoPC2", "BH_mitoPC2",
  "assoc72 subunits (resid): mitoPC2 equal-width gene-Manhattan (negative control)",
  file.path(outdir, "assoc72_resid_mitoPC2_geneEqualWidth_manhattan.png")
)
RSCRIPT

Rscript plot_assoc72_gene_equalwidth_manhattan_resid.R
















#去掉amo
Rscript - <<'RS'
library(ape)

# mt tree（和你画 noAMO 图用的是同一个）
tr <- read.tree("/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile")

# drop AMO
tr <- drop.tip(tr, "AMO")

# 距离矩阵
D <- cophenetic(tr)

# PCoA（一定要 eig=TRUE 才能算解释方差）
pco <- cmdscale(D, k = 5, eig = TRUE)

# 解释方差百分比
explained <- 100 * pco$eig / sum(pco$eig)

cat("Explained variance (no AMO):\n")
for(i in 1:5){
  cat(sprintf("  PC%d: %.2f%%\n", i, explained[i]))
}
RS
PC1: 49.54% PC2: 36.83% PC3: 10.06% PC4: 4.36% PC5: 2.81%





# 输入（你现在的 72 subunit AF long）
AF72=/mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz

# covariates 源（含 treePC）
COV=/mnt/spareHD_2/nu_287/covariates.treePC.tsv

# mt tree
MT_TREE=/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile

# 输出目录
OUTD=/mnt/spareHD_2/nu_287/_assoc72_subunit_AMOdrop
mkdir -p "$OUTD"

Rscript - <<'RS'
suppressPackageStartupMessages({library(data.table); library(dplyr); library(ape)})

cov_in  <- "/mnt/spareHD_2/nu_287/covariates.treePC.tsv"
mt_tree <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
cov_out <- "/mnt/spareHD_2/nu_287/_assoc72_subunit_AMOdrop/covariates.treePC.noAMO.tsv"

COV <- fread(cov_in)

# ---- 1) drop AMO from mt tree then recompute mitoPC ----
tr0 <- read.tree(mt_tree)
if("AMO" %in% tr0$tip.label){
  tr <- drop.tip(tr0, "AMO")
} else {
  tr <- tr0
}

D <- cophenetic(tr)
common <- intersect(COV$pop, rownames(D))
stopifnot(length(common) >= 3)

D2 <- D[common, common, drop=FALSE]
pco <- cmdscale(D2, k=3)
mitoPC <- data.frame(pop=rownames(pco),
                     mitoPC1=pco[,1], mitoPC2=pco[,2], mitoPC3=pco[,3])

# ---- 2) merge back with treePC covariates, and remove AMO row ----
COV2 <- COV %>%
  select(-starts_with("mitoPC")) %>%          # 换成新 mitoPC
  inner_join(mitoPC, by="pop") %>%
  filter(pop != "AMO")

fwrite(COV2, cov_out, sep="\t")
cat("[ok] wrote:", cov_out, " n_pops=", nrow(COV2), "\n")
RS

Rscript - <<'RS'
suppressPackageStartupMessages({
  library(ape)
  library(dplyr)
  library(ggplot2)
  library(ggrepel)
})

# ======================
# inputs / outputs
# ======================
mt_tree <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_dir <- "/mnt/spareHD_2/nu_287/_assoc72_subunit"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

# ======================
# helper: region labels
# ======================
add_region <- function(df){
  df %>%
    mutate(region = case_when(
      pop %in% c("FG","LG","SR","SL","TL","WB","WT","WK","LB") ~ "Alaska",
      pop %in% c("SWA","THE","JOE","BEA","MUC","PYE","ROS","BOOT","ECHO","LAW","GOS","ROB") ~ "BC",
      pop %in% c("RS","SAY") ~ "Marine",
      pop %in% c("PACH","FRED","SC","CH") ~ "Recent",
      TRUE ~ "Other"
    )) %>%
    arrange(region, pop)
}

# ======================
# theme: border + grid
# ======================
theme_border_grid <- function(){
  theme_bw(base_size = 12) +
    theme(
      panel.border     = element_rect(color = "black", fill = NA, linewidth = 0.9),
      panel.grid.major = element_line(color = "grey85", linewidth = 0.4),
      panel.grid.minor = element_blank(),  # 如果你想要次网格：改成 element_line(color="grey92", linewidth=0.3)
      panel.background = element_rect(fill = "white"),
      plot.title       = element_text(hjust = 0.5, face = "bold"),
      legend.title     = element_blank(),
      legend.position  = "right"
    )
}

# ======================
# 1) read tree + drop AMO
# ======================
tr <- read.tree(mt_tree)
if(!("AMO" %in% tr$tip.label)){
  stop("AMO not found in mt tree tips. Check tip labels.")
}
tr2 <- drop.tip(tr, "AMO")

# ======================
# 2) PCoA + explained variance
# ======================
D   <- cophenetic(tr2)
pco <- cmdscale(D, k = 3, eig = TRUE)

expl <- 100 * pco$eig / sum(pco$eig)
cat(sprintf("Explained variance (no AMO): PC1=%.2f%% PC2=%.2f%% PC3=%.2f%%\n",
            expl[1], expl[2], expl[3]))

PC <- data.frame(
  pop    = rownames(pco$points),
  mitoPC1 = pco$points[,1],
  mitoPC2 = pco$points[,2],
  mitoPC3 = pco$points[,3]
) %>% add_region()

# ======================
# 3) plots
# ======================
p_base <- ggplot(PC, aes(mitoPC1, mitoPC2, color = region)) +
  geom_point(size = 3, alpha = 0.9) +
  labs(
    x = sprintf("mitoPC1 (%.1f%%)", expl[1]),
    y = sprintf("mitoPC2 (%.1f%%)", expl[2]),
    title = "Mitochondrial PCoA after removing AMO"
  ) +
  theme_border_grid()

# with labels
p_label <- p_base +
  ggrepel::geom_text_repel(
    aes(label = pop),
    size = 3,
    max.overlaps = Inf,
    seed = 1
  )

# without labels (clean)
p_nolabel <- p_base

# ======================
# 4) save
# ======================
fn1_png <- file.path(out_dir, "mitoPC_noAMO_PC1_PC2.bordergrid.png")
fn1_pdf <- file.path(out_dir, "mitoPC_noAMO_PC1_PC2.bordergrid.pdf")
fn2_png <- file.path(out_dir, "mitoPC_noAMO_PC1_PC2.bordergrid.nolabel.png")
fn2_pdf <- file.path(out_dir, "mitoPC_noAMO_PC1_PC2.bordergrid.nolabel.pdf")

ggsave(fn1_png, p_label,   width = 7.2, height = 5.2, dpi = 300)
ggsave(fn1_pdf, p_label,   width = 7.2, height = 5.2)
ggsave(fn2_png, p_nolabel, width = 7.2, height = 5.2, dpi = 300)
ggsave(fn2_pdf, p_nolabel, width = 7.2, height = 5.2)

cat("[ok] wrote:\n", fn1_png, "\n", fn1_pdf, "\n", fn2_png, "\n", fn2_pdf, "\n")
RS




  Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo.R \
  /mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.noAMO_mitoPC.tsv \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit_noAMO







#noamo
# pc percentage  explained    /mnt/spareHD_2/nu_287/_assoc72_subunit/01_plot_mitoPC_noAMO.R

#!/usr/bin/env Rscript
suppressPackageStartupMessages({
  library(ape)
  library(data.table)
  library(dplyr)
  library(ggplot2)
  library(ggrepel)
})

mt_tree <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_dir <- "/mnt/spareHD_2/nu_287/_assoc72_subunit"
dir.create(out_dir, showWarnings=FALSE, recursive=TRUE)

# drop AMO
tr <- read.tree(mt_tree)
if("AMO" %in% tr$tip.label) tr <- drop.tip(tr, "AMO")

D <- cophenetic(tr)
pco <- cmdscale(D, k=5, eig=TRUE)

expl <- 100 * pco$eig / sum(pco$eig)
cat(sprintf("[mitoPC explained noAMO] PC1=%.2f%% PC2=%.2f%% PC3=%.2f%% PC4=%.2f%% PC5=%.2f%%\n",
            expl[1], expl[2], expl[3], expl[4], expl[5]))

PC <- data.frame(pop=rownames(pco$points),
                 mitoPC1=pco$points[,1],
                 mitoPC2=pco$points[,2],
                 mitoPC3=pco$points[,3])

PC <- PC %>%
  mutate(region = case_when(
    pop %in% c("FG","LG","SR","SL","TL","WB","WT","WK","LB") ~ "Alaska",
    pop %in% c("SWA","THE","JOE","BEA","MUC","PYE","ROS","BOOT","ECHO","LAW","GOS","ROB") ~ "BC",
    pop %in% c("RS","SAY") ~ "Marine",
    pop %in% c("PACH","FRED","SC","CH") ~ "Recent",
    TRUE ~ "Other"
  ))

p12 <- ggplot(PC, aes(mitoPC1, mitoPC2, color=region)) +
  geom_point(size=3, alpha=0.95) +
  ggrepel::geom_text_repel(aes(label=pop), size=3, max.overlaps=Inf, seed=1) +
  labs(
    x=sprintf("mitoPC1 (%.1f%%)", expl[1]),
    y=sprintf("mitoPC2 (%.1f%%)", expl[2]),
    title="Mitochondrial PCoA after removing AMO"
  ) +
  theme_bw(base_size=12) +        # ✅ 有边框
  theme(
    panel.grid.major = element_line(linewidth=0.3),
    panel.grid.minor = element_line(linewidth=0.2),
    legend.position="right"
  )

png(file.path(out_dir, "mitoPC_noAMO_PC1_PC2.theme_bw.png"), width=2200, height=1600, res=300)
print(p12)
dev.off()

pdf(file.path(out_dir, "mitoPC_noAMO_PC1_PC2.theme_bw.pdf"), width=7.2, height=5.2)
print(p12)
dev.off()

# 写 explained variance 表，补充材料用
exp_out <- file.path(out_dir, "mitoPC_noAMO_explained.tsv")
fwrite(data.table(PC=paste0("PC",1:5), explained_percent=expl[1:5]), exp_out, sep="\t")
cat("[write] ", exp_out, "\n")




#/mnt/spareHD_2/nu_287/_assoc72_subunit/02_make_covariates_noAMO_treePC2.R
#!/usr/bin/env Rscript
suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(ape)
})

# 输入
cov_in  <- "/mnt/spareHD_2/nu_287/covariates.treePC.tsv"  # 你原本 27pop 的 covariates（含 mitoPC、treePC）
mt_tree <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"

out_dir <- "/mnt/spareHD_2/nu_287/_assoc72_subunit"
dir.create(out_dir, showWarnings=FALSE, recursive=TRUE)
out_cov <- file.path(out_dir, "covariates.noAMO.treePC2_mitoPC2.tsv")

COV <- fread(cov_in)
COV <- COV[pop != "AMO"]
# 重新计算 mitoPC（drop AMO 后重算），避免“轴被旋转但 covariates 没更新”的问题
tr <- read.tree(mt_tree)
if("AMO" %in% tr$tip.label) tr <- drop.tip(tr, "AMO")
D <- cophenetic(tr)
pco <- cmdscale(D, k=3, eig=TRUE)
expl <- 100*pco$eig/sum(pco$eig)

mito <- data.table(pop=rownames(pco$points),
                   mitoPC1=pco$points[,1],
                   mitoPC2=pco$points[,2],
                   mitoPC3=pco$points[,3])

# 只替换 mitoPC*，treePC 仍用你 NJ tree 的 treePC1/2（与你主分析一致）
keep_cols <- setdiff(names(COV), c("mitoPC1","mitoPC2","mitoPC3"))
COV2 <- merge(COV[, ..keep_cols], mito, by="pop", all=FALSE)

fwrite(COV2, out_cov, sep="\t")
cat(sprintf("[write] %s (n=%d)\n", out_cov, nrow(COV2)))
cat(sprintf("[mitoPC explained noAMO] PC1=%.2f%% PC2=%.2f%% PC3=%.2f%%\n", expl[1], expl[2], expl[3]))

# 同时写解释率（给 Supplement）
exp_out <- file.path(out_dir, "covariates.noAMO.mitoPC_explained.tsv")
fwrite(data.table(PC=paste0("PC",1:5), explained_percent=expl[1:5]), exp_out, sep="\t")
cat("[write] ", exp_out, "\n")



Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo.R \
  /mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/covariates.noAMO.treePC2_mitoPC2.tsv \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit_noAMO


Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo_resid.R \
  /mnt/spareHD_2/nu_287/q2_parallelism/af_long_final_72genes_subunit_with_si.tsv.gz \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/covariates.noAMO.treePC2_mitoPC2.tsv \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit_noAMO
产出：

assoc72_subunit_noAMO_perSNP.tsv.gz

assoc72_subunit_noAMO_perSNP_resid.tsv.gz

assoc72_subunit_noAMO_covariates_resid.tsv

Rscript /mnt/spareHD_2/nu_287/_assoc72_subunit/check_lambda_fromPerSNP.R \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit_noAMO_perSNP.tsv.gz \
  noAMO_raw

Rscript /mnt/spareHD_2/nu_287/_assoc72_subunit/check_lambda_fromPerSNP.R \
  /mnt/spareHD_2/nu_287/_assoc72_subunit/assoc72_subunit_noAMO_perSNP_resid.tsv.gz \
  noAMO_resid


supply 1
/mnt/spareHD_2/nu_287/_assoc72_subunit/QQ_summary_4models/
├── assoc72_QQ_summary_table.tsv        ✅（核心汇总表）
├── QQ_withAMO_raw_PC1.png              ✅
├── QQ_withAMO_resid_PC1.png            ✅
├── QQ_noAMO_raw_PC1.png                ✅
├── QQ_noAMO_resid_PC1.png              ✅
├── QQ_withAMO_raw_PC2.png              ✅
├── QQ_withAMO_resid_PC2.png             ✅
├── QQ_noAMO_raw_PC2.png                 ✅
├── QQ_noAMO_resid_PC2.png               ✅

supply2
/mnt/spareHD_2/nu_287/_assoc72_subunit/
mitoPC_noAMO_PC1_PC2.theme_bw.png        ✅
mitoPC_noAMO_PC1_PC2.theme_bw.pdf        ✅
mitoPC_noAMO_explained.tsv               ✅


/mnt/spareHD_2/nu_287/_assoc72_subunit/gene_stability_4models$ ls
gene_table_all_models.tsv  jaccard_top10_propNominal.tsv  spearman_propNominal_pairwise.tsv  top10_by_propNominal.tsv
