#af regression

#path for sync files for 37+287 genes

/work/cyu/poolseq/PPalign_output/ann_mt_pergene_sync
/mnt/spareHD_2/nu_287/sync

# === Nuclear ===
NU_SYNC_DIR=/mnt/spareHD_2/nu_287/sync
NU_BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
NU_OUTD=/mnt/spareHD_2/nu_287

# === Mitochondrial ===
MT_SYNC_DIR=/work/cyu/poolseq/PPalign_output/ann_mt_pergene_sync
MT_BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
MT_OUTD=/mnt/spareHD_2/mt_gene_tree

# === Tree file for mitochondrial PCoA ===
MT_TREE=/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile

# === Script path ===
SYNC2AF=/mnt/spareHD_2/nu_287/sync2af.py


#STEP 1. .sync → Allele Frequency long table

#Script: /mnt/spareHD_2/nu_287/sync2af.py
#→ converts each per-gene .sync to long-format AF table.

1) .sync → 等位频长表 + 元信息（核 287 基因）
nano /mnt/spareHD_2/nu_287/sync2af.py
#!/usr/bin/env python3
import sys, os, gzip, re
from collections import defaultdict

"""
用法：
  python sync2af.py <sync_dir> <bamlist_for_order> <out_af_long.tsv.gz> <out_meta.tsv.gz>

说明：
- sync_dir：像 /mnt/spareHD_2/nu_287/sync 这种目录（每基因一个 .sync）
  文件名如 aars2.ENSGACG00000019994.sync → gene = aars2（取第一个点前的 symbol）
- bamlist_for_order：核的 bamlist（顺序=种群列顺序）
  /mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
  会从路径抽样本名：.../10_THE_S10_subset.bam → pop=10_THE_S10
- 输出1（长表）：chr pos gene pop af depth
- 输出2（元信息）：chr pos gene major
"""

def open_any(path):
    return gzip.open(path, "rt") if path.endswith(".gz") else open(path, "rt")

def pops_from_bamlist(bamlist):
    pops=[]
    with open(bamlist) as f:
        for line in f:
            line=line.strip()
            if not line: continue
            base=os.path.basename(line)
            base=re.sub(r"_subset\.bam$","",base)
            pops.append(base)
    return pops

def parse_counts(cell):
    # "A:C:G:T:N:del"
    a=cell.split(":")
    A,C,G,T = map(int, a[:4])
    return A,C,G,T

def guess_gene_from_filename(fn):
    # aars2.ENSGACG00000019994.sync(.gz) → aars2
    fn=re.sub(r"\.sync(\.gz)?$","",fn)
    return fn.split(".")[0]

def main(sync_dir, bamlist, out_af, out_meta):
    pops = pops_from_bamlist(bamlist)
    if not pops:
        print("No pops from bamlist", file=sys.stderr); sys.exit(2)

    outA = gzip.open(out_af, "wt")
    outM = gzip.open(out_meta, "wt")
    outA.write("chr\tpos\tgene\tpop\taf\tdepth\n")
    outM.write("chr\tpos\tgene\tmajor\n")

    for fn in sorted(os.listdir(sync_dir)):
        if not (fn.endswith(".sync") or fn.endswith(".sync.gz")): 
            continue
        gene = guess_gene_from_filename(fn)
        with open_any(os.path.join(sync_dir, fn)) as fp:
            for line in fp:
                if not line.strip(): continue
                toks=line.split()
                if len(toks) < 3+len(pops): 
                    continue
                chr_, pos, ref = toks[0], int(toks[1]), toks[2]
                cells = toks[3:3+len(pops)]

                # 全群体合并确定全局主等位
                tot={'A':0,'C':0,'G':0,'T':0}
                per=[]
                for i, pop in enumerate(pops):
                    A,C,G,T = parse_counts(cells[i])
                    tot['A']+=A; tot['C']+=C; tot['G']+=G; tot['T']+=T
                    per.append((pop,A,C,G,T))
                major = max(tot.items(), key=lambda x:x[1])[0]
                if tot[major]==0: 
                    continue

                outM.write(f"{chr_}\t{pos}\t{gene}\t{major}\n")
                for pop,A,C,G,T in per:
                    depth=A+C+G+T
                    if depth==0: 
                        continue
                    maj={'A':A,'C':C,'G':G,'T':T}[major]
                    af=maj/depth
                    outA.write(f"{chr_}\t{pos}\t{gene}\t{pop}\t{af:.6f}\t{depth}\n")

    outA.close(); outM.close()

if __name__=="__main__":
    if len(sys.argv)!=5:
        print(__doc__, file=sys.stderr); sys.exit(1)
    main(*sys.argv[1:])


SYNC_DIR=/mnt/spareHD_2/nu_287/sync
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
OUT_AF=/mnt/spareHD_2/nu_287/af_long.tsv.gz
OUT_META=/mnt/spareHD_2/nu_287/snp_meta.tsv.gz

python /mnt/spareHD_2/nu_287/sync2af.py "$SYNC_DIR" "$BAMLIST" "$OUT_AF" "$OUT_META"


SYNC_DIR=/work/cyu/poolseq/PPalign_output/ann_mt_pergene_sync
BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
OUT_AF=/mnt/spareHD_2/mt_gene_tree/mt_af_long.tsv.gz
OUT_META=/mnt/spareHD_2/mt_gene_tree/mt_snp_meta.tsv.gz

python /mnt/spareHD_2/nu_287/sync2af.py "$SYNC_DIR" "$BAMLIST" "$OUT_AF" "$OUT_META"



# 目录与清单（按你已有路径）
SYNC_DIR=/mnt/spareHD_2/nu_287/sync
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
OUT_AF=/mnt/spareHD_2/nu_287/af_long.tsv.gz
OUT_META=/mnt/spareHD_2/nu_287/snp_meta.tsv.gz

# 若你已保存了这个脚本，直接运行；若没有，把它保存到下面的路径再跑
python /mnt/spareHD_2/nu_287/sync2af.py "$SYNC_DIR" "$BAMLIST" "$OUT_AF" "$OUT_META"



# === 路径（按你现有目录已填好）===
SYNC_DIR=/mnt/spareHD_2/nu_287/sync
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
PY_SYNC2AF=/mnt/spareHD_2/nu_287/sync2af.py          # 我之前给你的脚本应保存在这里
OUTD=/mnt/spareHD_2/nu_287
MT_TREE=/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile

# 0) 先生成核 AF 长表（若未生成）
if [ ! -s "$OUTD/af_long.tsv.gz" ]; then
  if [ ! -s "$PY_SYNC2AF" ]; then
    echo "ERROR: 找不到 $PY_SYNC2AF（sync2af.py）。请先把我之前给你的 Python 脚本保存到这个路径。" >&2
    exit 2
  fi
  python "$PY_SYNC2AF" "$SYNC_DIR" "$BAMLIST" "$OUTD/af_long.tsv.gz" "$OUTD/snp_meta.tsv.gz"
fi

# 1) 用 R 一次性生成 af_matrix.tsv.gz + covariates.tsv
Rscript - <<'RS'
suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(tidyr); library(ape)
})

af_long <- "/mnt/spareHD_2/nu_287/af_long.tsv.gz"
out_mat <- "/mnt/spareHD_2/nu_287/af_matrix.tsv.gz"
mt_tree <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_cov <- "/mnt/spareHD_2/nu_287/covariates.tsv"

# --- 核 AF 长表 -> 宽矩阵 ---
AF <- fread(af_long)   # 需要列: chr pos gene pop af depth
stopifnot(all(c("chr","pos","gene","pop","af") %in% names(AF)))
AF <- AF %>% mutate(snp=paste(chr,pos,gene,sep=":")) %>%
             select(pop,snp,af) %>% distinct()

MAT <- AF %>% tidyr::pivot_wider(names_from=snp, values_from=af)
MAT <- as.data.frame(MAT); rownames(MAT) <- MAT$pop; MAT$pop <- NULL

# 列均值填补 NA
for(j in seq_len(ncol(MAT))){
  v <- MAT[[j]]; if(anyNA(v)) MAT[[j]][is.na(v)] <- mean(v, na.rm=TRUE)
}
# 写出矩阵
fwrite(MAT %>% tibble::rownames_to_column("pop"), out_mat, sep="\t")

# --- 核 PCA（nucPC1-2）---
pca <- prcomp(MAT, center=TRUE, scale.=TRUE)
nucPC <- data.frame(pop=rownames(pca$x), nucPC1=pca$x[,1], nucPC2=pca$x[,2])

# --- mt 树 → cophenetic 距离 → PCoA（mitoPC1-3）---
tr <- read.tree(mt_tree)
D  <- cophenetic(tr)
common <- intersect(rownames(MAT), rownames(D))
if(length(common)<3) stop("Overlapping pops < 3 between nuclear AF and mt tree.")
D <- D[common, common, drop=FALSE]
pco <- cmdscale(D, k=3)
mitoPC <- data.frame(pop=rownames(pco),
                     mitoPC1=pco[,1], mitoPC2=pco[,2], mitoPC3=pco[,3])

# --- 区域标签（按你既定分组）---
cov_region <- data.frame(pop = rownames(MAT)) %>%
  mutate(region = case_when(
    grepl("^(FG|LG|SR|SL|TL|WB|WT|WK|LB)", pop) ~ "Alaska",
    grepl("^(SWA|THE|JOE|BEA|MUC|PYE|ROS|AMO|BOOT|ECHO|LAW|GOS|ROB)", pop) ~ "BC",
    grepl("^(RS|SAY)", pop) ~ "Marine",
    grepl("^(PACH|FRED|SC|CH)", pop) ~ "Recent",
    TRUE ~ "Other"
  ))

# --- 合并并写出 covariates ---
covars <- nucPC %>% inner_join(mitoPC, by="pop") %>% inner_join(cov_region, by="pop")
fwrite(covars, out_cov, sep="\t")
cat("[ok] wrote:\n  ", out_mat, "\n  ", out_cov, "\n")
RS

# 2) 快速检查
ls -lh "$OUTD/af_long.tsv.gz" "$OUTD/af_matrix.tsv.gz" "$OUTD/covariates.tsv"



Rscript - <<'RS'
suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(tidyr); library(ape)
})

af_mat_gz <- "/mnt/spareHD_2/nu_287/af_matrix.tsv.gz"
mt_tree   <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_cov   <- "/mnt/spareHD_2/nu_287/covariates.tsv"

# ---------- 读核 AF 宽表 ----------
MAT0 <- fread(cmd = paste("zcat", shQuote(af_mat_gz)))
stopifnot("pop" %in% names(MAT0))

# 保存原始样本名，并标准化为“核心名”：
# 规则：拆分 '_'，若第一个是数字则取第二段；末尾若有 'subset' 或 'S\d+' 等后缀去掉
normalize_pop <- function(x){
  parts <- strsplit(x, "_", fixed = TRUE)
  vapply(parts, function(p){
    if (length(p)==1) return(p[1])
    # 去掉末尾“subset”等
    p <- p[ p!="subset" & p!="" ]
    if (length(p)>=2 && grepl("^[0-9]+$", p[1])) core <- p[2] else core <- p[1]
    # 再把像 'S1','S10' 这类末段去掉
    core <- gsub("^(.*?)(?:_S[0-9]+)?$", "\\1", core, perl=TRUE)
    toupper(core)
  }, character(1))
}

MAT0$core <- normalize_pop(MAT0$pop)

# 若同一 core 名出现多次，先聚合为均值
num_cols <- setdiff(names(MAT0), c("pop","core"))
MAT0[, (num_cols) := lapply(.SD, as.numeric), .SDcols = num_cols]
MAT_core <- MAT0 %>% group_by(core) %>% summarise(across(all_of(num_cols), ~ mean(.x, na.rm=TRUE))) %>% ungroup()

# 把 core 设为行名
MAT <- as.data.frame(MAT_core)
rownames(MAT) <- MAT$core
MAT$core <- NULL

# 丢全 NA 列
all_na <- names(MAT)[colSums(!is.na(MAT))==0]
if(length(all_na)) MAT[, all_na] <- NULL

# 列均值填补 NA
for(j in seq_len(ncol(MAT))){
  v <- MAT[[j]]
  if(anyNA(v)){
    m <- mean(v, na.rm=TRUE)
    if(is.finite(m)) MAT[[j]][is.na(MAT[[j]])] <- m
  }
}

# 丢零方差列
sds <- sapply(MAT, function(x) sd(x, na.rm=TRUE))
const_cols <- names(MAT)[!is.finite(sds) | sds==0]
if(length(const_cols)) MAT[, const_cols] <- NULL
cat("[info] SNP columns kept:", ncol(MAT), " removed:", length(all_na)+length(const_cols), "\n")

# ---------- 核 PCA ----------
if(ncol(MAT) < 2) stop("Too few informative SNP columns after filtering.")
pca <- prcomp(as.matrix(MAT), center=TRUE, scale.=TRUE)
nucPC <- data.frame(pop = rownames(pca$x),
                    nucPC1 = pca$x[,1],
                    nucPC2 = pca$x[,2])

# ---------- mt 树 → cophenetic → PCoA ----------
tr <- read.tree(mt_tree)
D  <- cophenetic(tr)
tree_pops <- rownames(D)

# 名字交集（以标准化后的核名为准）
common <- intersect(nucPC$pop, tree_pops)
cat("[match] AF pops:", length(unique(nucPC$pop)),
    " | tree tips:", length(tree_pops),
    " | intersection:", length(common), "\n")

if(length(common) < 3){
  cat("[WARN] Overlap < 3. Unmatched (AF-only):", paste(setdiff(nucPC$pop, tree_pops), collapse=","), "\n")
  cat("[WARN] Unmatched (tree-only):", paste(setdiff(tree_pops, nucPC$pop), collapse=","), "\n")
  stop("Need >=3 overlapping pops for PCoA.")
}

# PCoA 仅对交集
D2 <- D[common, common, drop=FALSE]
pco <- cmdscale(D2, k=3)
mitoPC <- data.frame(pop = rownames(pco),
                     mitoPC1 = pco[,1], mitoPC2 = pco[,2], mitoPC3 = pco[,3])

nucPC2 <- nucPC %>% filter(pop %in% common)

# ---------- 区域标签 ----------
cov_region <- data.frame(pop = common) %>%
  mutate(region = case_when(
    grepl("^(FG|LG|SR|SL|TL|WB|WT|WK|LB)$", pop) ~ "Alaska",
    grepl("^(SWA|THE|JOE|BEA|MUC|PYE|ROS|AMO|BOOT|ECHO|LAW|GOS|ROB)$", pop) ~ "BC",
    grepl("^(RS|SAY)$", pop) ~ "Marine",
    grepl("^(PACH|FRED|SC|CH)$", pop) ~ "Recent",
    TRUE ~ "Other"
  ))

# ---------- 合并并写出 ----------
covars <- nucPC2 %>% inner_join(mitoPC, by="pop") %>% inner_join(cov_region, by="pop")
fwrite(covars, out_cov, sep="\t")
cat("[ok] wrote:", out_cov, "  (n_pops=", nrow(covars), ")\n")

# 打印未匹配清单（方便你核查样本名）
af_only <- setdiff(nucPC$pop, tree_pops)
tree_only <- setdiff(tree_pops, nucPC$pop)
if(length(af_only))  cat("[AF-only names]", paste(af_only, collapse=", "), "\n")
if(length(tree_only)) cat("[Tree-only names]", paste(tree_only, collapse=", "), "\n")
RS

# 查看结果
ls -lh /mnt/spareHD_2/nu_287/covariates.tsv




#tree pca
#!/usr/bin/env Rscript
# Construct covariate table for Step 3 association model
#   - Nuclear PCs from allele frequencies (population structure)
#   - Mito PCs from mt tree (haplotype structure)
#   - Tree PCs from nuclear phylogeny (neutral background)
# Output: covariates.treePC.tsv

library(ape)

# 读你刚 scp 上去的 NJ 树（用 unrooted 那个就行）
tr0 <- read.tree("/work/cyu/unrooted_NJ_tree.tree")

# 你要保留的 27 个种群名字（就是你一直用的那一套）
pops27 <- c(
  "THE","AMO","SWA","JOE","BEA","MUC","FRED","PACH","LB","SAY",
  "CH","RS","SC","SL","WK","WT","TL","SR","LG","FG","WB",
  "PYE","ROB","LAW","GOS","ECHO","BOOT"
)

# 看看树里有哪些 tip
tree_tips <- sort(tr0$tip.label)
cat("tree tips:\n"); print(tree_tips)

# 找出“树里有但不在 27 个名单里的” → 就是多余的
extra <- setdiff(tree_tips, pops27)
cat("extra tips to drop:\n"); print(extra)
# 这里你已经看到是 "ROS"

# 删掉 ROS
tr <- drop.tip(tr0, extra)

# 存一份干净的 27 种群 neutral 树
write.tree(tr, file = "/work/cyu/unrooted_NJ_tree_27.tree")


library(ape)

tr <- read.tree("/work/cyu/unrooted_NJ_tree_27.tree")

# 1) 树 → 成对距离矩阵
D <- cophenetic(tr)   # 27 x 27，没有 NA 就对了

# 2) 距离矩阵 → PCoA / MDS，取前三个轴
pco <- cmdscale(D, k = 3)

treePC <- data.frame(
  pop     = rownames(pco),
  treePC1 = pco[, 1],
  treePC2 = pco[, 2],
  treePC3 = pco[, 3]
)

# 存到一个表里，后面当 covariate 用
out_treepc <- "/mnt/spareHD_2/nu_287/treePC_from_NJ.tsv"
write.table(treePC, out_treepc,
            sep = "\t", quote = FALSE, row.names = FALSE)
cat("wrote tree PCs to:", out_treepc, "\n")

library(data.table)
library(dplyr)

cov_path   <- "/mnt/spareHD_2/nu_287/covariates.tsv"
treepc_path <- "/mnt/spareHD_2/nu_287/treePC_from_NJ.tsv"
out_cov2   <- "/mnt/spareHD_2/nu_287/covariates.treePC.tsv"

# 1) 读旧的 covariates（里面有 mitoPC 和 region）
COV <- fread(cov_path)

# 2) 读我们刚算的 treePC
TPC <- fread(treepc_path)

# 3) 把旧的 nucPC1/2/3 去掉（只保留 pop / mitoPC* / region）
COV2 <- COV %>%
  select(-starts_with("nucPC"))

# 4) 合并进 treePC（按 pop 匹配）
COV3 <- COV2 %>%
  inner_join(TPC, by = "pop")

# 看一眼列名
print(colnames(COV3))

# 5) 写出新的 covariates
fwrite(COV3, out_cov2, sep = "\t")
cat("new covariates with treePC written to:", out_cov2, "\n")



suppressPackageStartupMessages({
  library(data.table); library(dplyr); library(tidyr); library(ape)
})

# === Paths ===
af_mat_gz <- "/mnt/spareHD_2/nu_287/af_matrix.tsv.gz"
mt_tree   <- "/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile"
out_cov   <- "/mnt/spareHD_2/nu_287/covariates.treePC.tsv"

# === 1. Read nuclear AF matrix ===
MAT0 <- fread(cmd=paste("zcat",shQuote(af_mat_gz)))
stopifnot("pop" %in% names(MAT0))

# simplify pop names (10_THE_S10 → THE)
normalize_pop <- function(x){
  parts <- strsplit(x,"_")
  vapply(parts,function(p){
    core <- if(length(p)>=2 && grepl("^[0-9]+$",p[1])) p[2] else p[1]
    core <- gsub("^(.*?)(_S[0-9]+)?$","\\1",core)
    toupper(core)
  },character(1))
}
MAT0$core <- normalize_pop(MAT0$pop)
MAT_core <- MAT0 %>%
  group_by(core) %>%
  summarise(across(where(is.numeric),mean,na.rm=TRUE))
MAT <- as.data.frame(MAT_core); rownames(MAT)<-MAT$core; MAT$core<-NULL

# fill NA with column mean
for(j in seq_len(ncol(MAT))){
  v<-MAT[[j]]; if(anyNA(v)) MAT[[j]][is.na(v)]<-mean(v,na.rm=TRUE)
}
# remove constant columns
MAT <- MAT[,apply(MAT,2,sd,na.rm=TRUE)>0]

# === 2. Nuclear PCA ===
pca <- prcomp(MAT, center=TRUE, scale.=TRUE)
nucPC <- data.frame(pop=rownames(pca$x),
                    nucPC1=pca$x[,1], nucPC2=pca$x[,2], nucPC3=pca$x[,3])

# === 3. Mitochondrial tree PCoA ===
tr <- read.tree(mt_tree)
D  <- cophenetic(tr)
common <- intersect(rownames(MAT), rownames(D))
D2 <- D[common, common]
pco <- cmdscale(D2, k=3)
mitoPC <- data.frame(pop=rownames(pco),
                     mitoPC1=pco[,1], mitoPC2=pco[,2], mitoPC3=pco[,3])

# === 4. Region labels ===
cov_region <- data.frame(pop=common) %>%
  mutate(region=case_when(
    grepl("^(FG|LG|SR|SL|TL|WB|WT|WK|LB)$",pop) ~ "Alaska",
    grepl("^(SWA|THE|JOE|BEA|MUC|PYE|ROS|AMO|BOOT|ECHO|LAW|GOS|ROB)$",pop) ~ "BC",
    grepl("^(RS|SAY)$",pop) ~ "Marine",
    grepl("^(PACH|FRED|SC|CH)$",pop) ~ "Recent",
    TRUE ~ "Other"
  ))

# === 5. Merge ===
covars <- nucPC %>%
  inner_join(mitoPC, by="pop") %>%
  inner_join(cov_region, by="pop")

fwrite(covars, out_cov, sep="\t")
cat("[ok] wrote:", out_cov, " (n_pops=", nrow(covars), ")\n")


生成/mnt/spareHD_2/nu_287/covariates.treePC.tsv



#Step 3 : Per-SNP Association Model
#!/usr/bin/env Rscript
# Per-SNP association: allele frequency vs mitoPC + treePC
# Model: AF_pop ~ mitoPC1 + mitoPC2 + treePC1 + treePC2

suppressPackageStartupMessages({
  library(data.table); library(dplyr)
})

args <- commandArgs(trailingOnly=TRUE)
if(length(args)!=3){
  cat("Usage: Rscript run_assoc_perSNP_haplo.R <af_long.tsv.gz> <covariates.tsv> <out_prefix>\n")
  quit("no")
}

af_file <- args[1]; cov_file <- args[2]; out_prefix <- args[3]
cat("[input]\n AF :",af_file,"\n COV:",cov_file,"\n OUT:",out_prefix,"\n")

AF  <- fread(cmd=paste("zcat",shQuote(af_file)))
COV <- fread(cov_file)

# simplify pop name to match covariates
normalize_pop <- function(x){
  gsub("^(\\d+_)?([A-Za-z]+)(_S\\d+)?$", "\\2", x)
}
AF$pop <- toupper(normalize_pop(AF$pop))

dat <- inner_join(AF, COV, by="pop")
cat("[info] N rows after merge:",nrow(dat),"\n")

# run regression per SNP
genes <- unique(dat$gene)
out <- list()

for(g in genes){
  sub <- dat[dat$gene==g,]
  snps <- unique(paste(sub$chr,sub$pos,sep=":"))
  for(snp in snps){
    tmp <- sub[paste(chr,pos,sep=":")==snp,]
    if(nrow(tmp)<5) next
    fit <- try(lm(af ~ mitoPC1 + mitoPC2 + treePC1 + treePC2, data=tmp), silent=TRUE)
    if(inherits(fit,"try-error")) next
    summ <- summary(fit)
    pvals <- coef(summ)[,4]
    R2 <- summ$r.squared
    out[[length(out)+1]] <- data.frame(
      chr=tmp$chr[1],
      pos=tmp$pos[1],
      gene=tmp$gene[1],
      p_mitoPC1=pvals["mitoPC1"],
      p_mitoPC2=pvals["mitoPC2"],
      R2=R2,
      n=nrow(tmp)
    )
  }
}

RES <- bind_rows(out)
RES$BH_mitoPC1 <- p.adjust(RES$p_mitoPC1, method="BH")
RES$BH_mitoPC2 <- p.adjust(RES$p_mitoPC2, method="BH")
out_file <- paste0(out_prefix,"_perSNP.tsv.gz")
fwrite(RES, out_file, sep="\t")
cat("[ok] wrote:", out_file, "  (SNPs:", nrow(RES), ")\n")


Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo.R \
  /mnt/spareHD_2/nu_287/af_long.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.tsv \
  /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo

/mnt/spareHD_2/nu_287/

_assoc_perGene_sigCount.tsv.gz
_assoc_perSNP_haplo_perSNP.tsv.gz

#resid  /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo_resid.R

#!/usr/bin/env Rscript
# ------------------------------------------------------------
# Per-SNP association (residualized)
# Control for treePC1, treePC2 before regression
# Model: AF_pop ~ mitoPC1_resid + mitoPC2_resid
# ------------------------------------------------------------

suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
})

args <- commandArgs(trailingOnly=TRUE)
if (length(args) != 3) {
  cat("Usage: Rscript run_assoc_perSNP_haplo_resid.R <af_long.tsv.gz> <covariates.tsv> <out_prefix>\n")
  quit("no")
}

af_file  <- args[1]
cov_file <- args[2]
out_pref <- args[3]

cat("[input]\n  AF :", af_file, "\n  COV:", cov_file, "\n  OUT:", out_pref, "\n")

AF  <- fread(cmd=paste("zcat", shQuote(af_file)))
COV <- fread(cov_file)

# ==== Residualize mitoPCs against treePCs ====
r1 <- lm(mitoPC1 ~ treePC1 + treePC2, data=COV)
r2 <- lm(mitoPC2 ~ treePC1 + treePC2, data=COV)
COV$mitoPC1_resid <- resid(r1)
COV$mitoPC2_resid <- resid(r2)

cat("[resid] mitoPC1 vs treePC → cor =", round(cor(COV$mitoPC1, COV$treePC1),3),
    ", mitoPC2 vs treePC → cor =", round(cor(COV$mitoPC2, COV$treePC1),3), "\n")

out_cov <- paste0(out_pref, "_covariates_resid.tsv")
fwrite(COV, out_cov, sep="\t")
cat("[ok] wrote:", out_cov, "\n")

# ==== Merge AF and covariates ====
normalize_pop <- function(x) {
  gsub("^(\\d+_)?([A-Za-z]+)(_S\\d+)?$", "\\2", x)
}
AF$pop <- toupper(normalize_pop(AF$pop))
DAT <- inner_join(AF, COV, by="pop")

cat("[info] merged rows:", nrow(DAT), "\n")

# ==== Regression per SNP ====
genes <- unique(DAT$gene)
out <- list()

pb <- txtProgressBar(min=0, max=length(genes), style=3)
for (i in seq_along(genes)) {
  g <- genes[i]
  sub <- DAT[DAT$gene == g, ]
  snps <- unique(paste(sub$chr, sub$pos, sep=":"))
  for (snp in snps) {
    tmp <- sub[paste(chr,pos,sep=":") == snp, ]
    if (nrow(tmp) < 5) next
    fit <- try(lm(af ~ mitoPC1_resid + mitoPC2_resid, data=tmp), silent=TRUE)
    if (inherits(fit,"try-error")) next
    summ <- summary(fit)
    pvals <- coef(summ)[,4]
    R2 <- summ$r.squared
    out[[length(out)+1]] <- data.frame(
      chr=tmp$chr[1],
      pos=tmp$pos[1],
      gene=tmp$gene[1],
      p_mitoPC1=pvals["mitoPC1_resid"],
      p_mitoPC2=pvals["mitoPC2_resid"],
      R2=R2,
      n=nrow(tmp)
    )
  }
  setTxtProgressBar(pb, i)
}
close(pb)

RES <- bind_rows(out)
RES$BH_mitoPC1 <- p.adjust(RES$p_mitoPC1, method="BH")
RES$BH_mitoPC2 <- p.adjust(RES$p_mitoPC2, method="BH")

out_file <- paste0(out_pref, "_perSNP_resid.tsv.gz")
fwrite(RES, out_file, sep="\t")
cat("[ok] wrote:", out_file, " (", nrow(RES), " SNPs)\n")


Rscript /mnt/spareHD_2/nu_287/run_assoc_perSNP_haplo_resid.R \
  /mnt/spareHD_2/nu_287/af_long.tsv.gz \
  /mnt/spareHD_2/nu_287/covariates.treePC.tsv \
  /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo

[resid] mitoPC1 vs treePC → cor = -0.083 , mitoPC2 vs treePC → cor = 0.11




/mnt/spareHD_2/nu_287/

原始 per-SNP 回归（含 treePC）
│
├──▶ _assoc_perSNP_haplo_perSNP.tsv.gz        ← 全 SNP 原始结果
│
└──▶ 残差化 mitoPC1/2（去掉 tree 影响）
      │
      ├──▶ _assoc_perSNP_haplo_perSNP_resid.tsv.gz   ← 全 SNP 残差结果
      │
      └──▶ _assoc_perSNP_haplo_perSNP_resid_sig.tsv.gz ← 仅保留显著 SNP (FDR<0.05)

zcat /mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP_resid_sig.tsv.gz \
  | awk 'NR>1 {print $3}' | sort | uniq -c | sort -k1,1nr | head
80  eprs
76  mrpl49
53  iars2
46  vars2
44  iars
44  vars
38  aars2
37  ndufs1
36  cep89
34  aifm1



#check lamda before resid
#!/usr/bin/env Rscript
# Calculate genomic inflation factor λ for mitoPC1 and mitoPC2 (original model)

suppressPackageStartupMessages(library(data.table))

# --- Input file (non-residual model) ---
file <- "/mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP.tsv.gz"

cat("[input] ", file, "\n")

# --- Read data ---
df <- fread(cmd = paste("zcat", shQuote(file)))
df <- df[is.finite(p_mitoPC1) & is.finite(p_mitoPC2)]

# --- Calculate chi² for each test (df=1) ---
df$chi1 <- qchisq(1 - df$p_mitoPC1, 1)
df$chi2 <- qchisq(1 - df$p_mitoPC2, 1)

# --- Expected median chi² under null ---
median_null <- qchisq(0.5, 1)

# --- Inflation factors ---
lambda1 <- median(df$chi1, na.rm=TRUE) / median_null
lambda2 <- median(df$chi2, na.rm=TRUE) / median_null

cat("λ_mitoPC1 =", round(lambda1, 3),
    "\nλ_mitoPC2 =", round(lambda2, 3), "\n")


#!/usr/bin/env Rscript check_lambda_resid.R
# Calculate genomic inflation factor λ for mitoPC1/2 (residualized model)

suppressPackageStartupMessages(library(data.table))

file <- "/mnt/spareHD_2/nu_287/_assoc_perSNP_haplo_perSNP_resid.tsv.gz"

cat("[input] ", file, "\n")

df <- fread(cmd = paste("zcat", shQuote(file)))
df <- df[is.finite(p_mitoPC1) & is.finite(p_mitoPC2)]

df$chi1 <- qchisq(1 - df$p_mitoPC1, 1)
df$chi2 <- qchisq(1 - df$p_mitoPC2, 1)

median_null <- qchisq(0.5, 1)
lambda1 <- median(df$chi1, na.rm=TRUE) / median_null
lambda2 <- median(df$chi2, na.rm=TRUE) / median_null

cat("λ_mitoPC1_resid =", round(lambda1, 3),
    "\nλ_mitoPC2_resid =", round(lambda2, 3), "\n")





#mtpc
# 载入系统发育树
library(ape)
tr <- read.tree("/work/cyu/poolseq/PPalign_output/overlap.vcf/consensus/aligned_mt_noDloop.fasta.treefile")
D  <- cophenetic(tr)

# 运行 PCoA
pco <- cmdscale(D, k=3, eig=TRUE)

# 输出方差解释比例
explained <- 100 * pco$eig / sum(pco$eig)
explained[1:5]
cat("Variance explained by mitoPC1-3:\n")
cat(sprintf("  PC1: %.2f%%\n  PC2: %.2f%%\n  PC3: %.2f%%\n",
            explained[1], explained[2], explained[3]))
