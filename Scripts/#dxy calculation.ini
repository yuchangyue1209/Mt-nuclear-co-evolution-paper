#dxy calculation
# nuclear mileup merge BAM files (in the order of the file paths in BAMlist.txt) in a MPILEUP file only retaining nucleotides with BQ >20 and reads with MQ > 20
cd /mnt/spareHD_2/marked_duplicates/
samtools mpileup -B \
    -f /work/cyu/stickleback_nuclear_only.fa \
    -b bamlist.txt \
    -q 30 \
    -Q 30 \
    -d 5000 \
    | gzip > nuclear.mpileup.gz

gunzip /mnt/spareHD_2/marked_duplicates/nuclear.mpileup.gz

/mnt/spareHD_2/nuclear_marked_duplicates/nuclear.mpileup

perl mpileup2sync.pl \
    --input /mnt/spareHD_2/nuclear_marked_duplicates/crispr.mpileup \
    --output /mnt/spareHD_2/nuclear_marked_duplicates/nuclear.sync \
    --fastq-type sanger \
    --min-qual 20

#mt mileup
1.#create bam.list
ls -1 /work/cyu/poolseq/PPalign_output/mtDNA_bam/*.bam > /work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt

# merge BAM files (in the order of the file paths in BAMlist.txt) in a MPILEUP file only retaining nucleotides with BQ >20 and reads with MQ > 20
samtools mpileup -B \
    -f /work/cyu/sequence.fasta \
    -b bamlist.txt \
    -q 30 \
    -Q 30 \
    -d 5000 \
    | gzip > fish.mpileup.gz

perl mpileup2sync.pl \
    --input /work/cyu/poolseq/PPalign_output/mtDNA_bam/fish.mpileup \
    --output /work/cyu/poolseq/PPalign_output/mtDNA_bam/fish.sync \
    --fastq-type sanger \
    --min-qual 20


#bed files
#!/bin/bash

# === è¾“å…¥æ–‡ä»¶è·¯å¾„ ===
SYNC="/mnt/spareHD_2/nuclear_marked_duplicates/nuclear.sync"
BED="/work/cyu/nuOXPHOS_genes_with_complex_core.bed"
OUTDIR="/mnt/spareHD_2/nuclear/bed"
mkdir -p "$OUTDIR"

# === Step 1: ç”Ÿæˆ BED æ ¼å¼çš„ sync æ–‡ä»¶ ===
echo "ğŸ“¦ Generating nuclear.sync.bed..."
awk '{print $1, $2, $2+1, $0}' OFS='\t' "$SYNC" > "$OUTDIR/nuclear.sync.bed"

# === Step 2: ç”Ÿæˆå­é›† BED æ–‡ä»¶ ===
echo "ğŸ”§ Splitting BED annotations..."
awk '$8 == "core"' "$BED" > "$OUTDIR/core.bed"
awk '$8 == "noncore"' "$BED" > "$OUTDIR/noncore.bed"
awk '$9 == "contact"' "$BED" > "$OUTDIR/contact.bed"
awk '$9 == "noncontact"' "$BED" > "$OUTDIR/noncontact.bed"

# åˆ†åˆ«æå– complex I-V
for c in I II III IV V; do
    awk -v C="$c" '$7 == C' "$BED" > "$OUTDIR/complex${c}.bed"
done

# === Step 3: æå–äº¤é›† SNPs ===
echo "ğŸ§¬ Extracting SNPs by category..."

bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/core.bed" > "$OUTDIR/core.sync"
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/noncore.bed" > "$OUTDIR/noncore.sync"
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/contact.bed" > "$OUTDIR/contact.sync"
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/noncontact.bed" > "$OUTDIR/noncontact.sync"

for c in I II III IV V; do
    echo "ğŸ” Extracting SNPs for Complex $c..."
    bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/complex${c}.bed" > "$OUTDIR/complex${c}.sync"
done

# æ‰€æœ‰ nuOXPHOS åŒºåŸŸ SNP
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$BED" > "$OUTDIR/all_nuOXPHOS.sync"

echo "âœ… All output files saved to $OUTDIR"


#å»æ‰å‰ä¸‰åˆ—
#!/bin/bash

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR="/mnt/spareHD_2/nuclear/bed"
cd "$WORKDIR" || exit 1

echo "ğŸ” Processing *.sync files in: $WORKDIR"

# éå†æ‰€æœ‰ .sync æ–‡ä»¶ï¼ˆæ’é™¤ *_fixed.syncï¼‰
for FILE in *.sync; do
    # è·³è¿‡å·²å¤„ç†çš„æ–‡ä»¶
    if [[ "$FILE" == *_fixed.sync ]]; then
        continue
    fi

    BASENAME="${FILE%.sync}"
    FIXED="${BASENAME}_fixed.sync"

    echo "ğŸ“‚ Converting $FILE -> $FIXED"
    cut -f4- "$FILE" > "$FIXED"
done

echo "âœ… Done. All *_fixed.sync files are created."




#!/usr/bin/env Rscript
# calc_dxy.R

# å®‰è£…/åŠ è½½ä¾èµ–åŒ…
if (!requireNamespace("data.table", quietly=TRUE)) install.packages("data.table")
if (!requireNamespace("parallel", quietly=TRUE)) install.packages("parallel")
library(data.table)
library(parallel)

# 1. è§£æ .sync æ–‡ä»¶ï¼Œç”Ÿæˆç­‰ä½åŸºå› é¢‘ç‡çŸ©é˜µ
# è¾“å…¥ï¼šè·¯å¾„ï¼Œç¾¤ä½“æ•°
read_sync_freq <- function(sync_path, npops=27) {
  # è¯»å– syncï¼ˆè·³è¿‡å‰ä¸‰åˆ—ï¼šchr, pos, refï¼‰
  cols <- c("chr","pos","ref", paste0("pop",1:npops))
  sync <- fread(sync_path, header=FALSE, col.names=cols, showProgress=FALSE)
  
  # åªå– counts åˆ—
  pop_cols <- cols[4:length(cols)]
  
  # è§£æå‡½æ•°ï¼šå–ç¬¬ä¸€ä¸ªç¢±åŸºï¼ˆrefï¼‰é¢‘ç‡
  parse_freq <- function(x) {
    cnt <- as.integer(strsplit(x,":")[[1]][1:4])
    tot <- sum(cnt)
    if (tot==0) return(NA_real_)
    cnt[1]/tot
  }
  
  # å¹¶è¡ŒåŒ–è§£æï¼šæ¯ä¸€åˆ—ä¸€ä¸ªè¿›ç¨‹
  freq_mat <- mclapply(pop_cols, function(col) {
    vapply(sync[[col]], parse_freq, numeric(1))
  }, mc.cores=detectCores())
  
  freq <- do.call(cbind, freq_mat)
  colnames(freq) <- pop_cols
  rownames(freq) <- paste0(sync$chr, ":", sync$pos)
  return(freq)
}

# 2. è®¡ç®—æˆå¯¹ dXY
calc_pairwise_dxy <- function(freq_mat) {
  pops <- colnames(freq_mat)
  n <- ncol(freq_mat)
  # result çŸ©é˜µ
  m <- matrix(NA, n, n, dimnames=list(pops, pops))
  
  # å•ä¸ªä½ç‚¹ dxy
  calc_site <- function(p, q) p*(1-q) + (1-p)*q
  
  for (i in seq_len(n)) {
    for (j in i:n) {
      p <- freq_mat[,i]; q <- freq_mat[,j]
      dsite <- calc_site(p, q)
      m[i,j] <- m[j,i] <- mean(dsite, na.rm=TRUE)
    }
  }
  return(m)
}

# 3. ä¸»æµç¨‹
args <- commandArgs(trailingOnly=TRUE)
if (length(args)!=2) {
  stop("Usage: Rscript calc_dxy.R <nuclear.sync> <mt.sync>")
}
nuc_sync <- args[1]
mt_sync  <- args[2]

cat("Reading nuclear sync...\n")
freq_nu <- read_sync_freq(nuc_sync)
cat("Computing nuclear dXY matrix...\n")
dxy_nu  <- calc_pairwise_dxy(freq_nu)

cat("Reading mt sync...\n")
freq_mt <- read_sync_freq(mt_sync)
cat("Computing mt dXY matrix...\n")
dxy_mt  <- calc_pairwise_dxy(freq_mt)

# 4. ä¿å­˜ç»“æœ
write.csv(dxy_nu, "dxy_nuclear_matrix.csv", quote=FALSE)
write.csv(dxy_mt,  "dxy_mt_matrix.csv",     quote=FALSE)

cat("Done! Results in dxy_nuclear_matrix.csv and dxy_mt_matrix.csv\n")



Rscript calc_dxy.R /mnt/spareHD_2/nuclear/bed/all_nuOXPHOS_fixed.sync /work/cyu/poolseq/PPalign_output/ann/fish_pcg_fixed.sync




#heatmap
#!/usr/bin/env Rscript

pkgs <- c("data.table", "pheatmap")
for (pkg in pkgs) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, repos = "https://cloud.r-project.org")
  }
}
library(data.table)
library(pheatmap)

args <- commandArgs(trailingOnly = TRUE)
if (length(args) != 2) {
  stop("Usage: Rscript dxy_heatmap_plot.R <dxy_matrix.csv> <bamlist.txt>")
}
dxy_file <- args[1]
bamlist_file <- args[2]

# è¯»å– dXY matrix
dxy <- fread(dxy_file, data.table = FALSE)
rownames(dxy) <- dxy[[1]]
dxy <- dxy[,-1]

# è¯»å– bamlistï¼Œæå–ç§ç¾¤åï¼ˆå¤§å†™ï¼‰
bamlist <- fread(bamlist_file, header = FALSE)[[1]]
sample_names <- basename(bamlist)
pops <- toupper(gsub(".*?_([A-Za-z]+)_.*", "\\1", sample_names))

if (length(pops) != ncol(dxy)) stop("Mismatch between BAM list and dXY matrix columns")

colnames(dxy) <- pops
rownames(dxy) <- pops

# è‡ªå®šä¹‰è“è‰²æ¸å˜è‰²å›¾ï¼ˆæµ…è“ç™½åˆ°æ·±è“ï¼‰
my_colors <- colorRampPalette(c("#eaf3fa", "#2b7bba"))(100)

# ä¿å­˜ä¸º PDF æ–‡ä»¶
pdf("dxy_mt_matrix_heatmap.pdf", width = 8, height = 8)
pheatmap(dxy,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "average",
         color = my_colors,
         main = "Pairwise dXY Heatmap",
         angle_col = 45,
         fontsize = 10)
dev.off()

cat("âœ… Heatmap saved as dxy_mt_matrix_heatmap.pdf\n")
Rscript dxy_heatmap_plot.R dxy_mt_matrix.csv /work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt

