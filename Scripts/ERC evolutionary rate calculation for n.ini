#ERC evolutionary rate calculation for nuclear and mt OXPHOS genes
#mito
/work/cyu/poolseq/PPalign_output/ann/*_fixed.sync



#################### 0. 生成 POPS 数组 ####################
BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt   # ← mtDNA bamlist

# 从路径中抽出样本 ID，顺序与 bamlist 完全一致
POPS=($(awk -F'/' '{sub(/_mtDNA\.bam$/,"",$NF); print $NF}' "$BAMLIST"))

echo "检测到 ${#POPS[@]} 个种群："
echo "${POPS[@]}"
# 确认输出应为：10_THE 11_JOE … 9_SWA  共 27 个

#################### 1. sync → cf 批量转换 ####################
SYNC_DIR=/work/cyu/poolseq/PPalign_output/ann         # 你的 13 mt 基因 sync 目录
CF_DIR=/mnt/spareHD_2/mt_gene_tree/counts
mkdir -p "$CF_DIR"

# 13 个 mt 基因名（按你的命名）
GENES=(ND1 ND2 COX1 COX2 ATP8 ATP6 COX3 ND3 ND4L ND4 ND5 ND6 CYTB)

for GENE in "${GENES[@]}"; do
  S="$SYNC_DIR/${GENE}_fixed.sync"
  [[ -s "$S" ]] || { echo "⚠ 跳过空文件 $S"; continue; }

  python /mnt/spareHD_2/mt_gene_tree/counts/1.py \
         "$S" "$CF_DIR/${GENE}.cf" "${POPS[@]}"
done

echo "✅ counts(.cf) 写入 $CF_DIR"


#n=2
#!/usr/bin/env bash
set -euo pipefail

#################### 0) 物种顺序（按 bamlist） ####################
BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
# 提取样本 ID（去掉 _mtDNA.bam），顺序与 bamlist 完全一致
readarray -t POPS < <(awk -F'/' '{sub(/_mtDNA\.bam$/,"",$NF); print $NF}' "$BAMLIST")

echo "检测到 ${#POPS[@]} 个种群："
echo "${POPS[@]}"
echo

#################### 1) sync → cf 批量转换 ####################
SYNC_DIR=/work/cyu/poolseq/PPalign_output/ann
CF_DIR=/mnt/spareHD_2/mt_gene_tree/counts_top1
SCRIPT=/mnt/spareHD_2/mt_gene_tree/counts/sync2cf_pomo_fix.py  # 见下方 Python
TOPN=1   # ← 按你的要求：每个位点保留前 2 个等位

mkdir -p "$CF_DIR"

GENES=(ND1 ND2 COX1 COX2 ATP8 ATP6 COX3 ND3 ND4L ND4 ND5 ND6 CYTB)

for GENE in "${GENES[@]}"; do
  S="$SYNC_DIR/${GENE}_fixed.sync"
  O="$CF_DIR/${GENE}.cf"

  if [[ ! -s "$S" ]]; then
    echo "⚠ 跳过：找不到或空文件 $S"
    continue
  fi

  echo "🔄 生成 CF：$GENE"
  python "$SCRIPT" "$S" "$O" "${POPS[@]}" --topN "$TOPN"

  # 读取 CF 头一行打印 NSITES
  if [[ -s "$O" ]]; then
    NSITES=$(awk 'NR==1{for(i=1;i<=NF;i++) if($i=="NSITES"){print $(i+1); exit}}' "$O")
    echo "✅ counts(.cf) 写入 $CF_DIR （NSITES=${NSITES:-0}） → $O"
  else
    echo "❗ 生成失败：$O 为空"
  fi
done



#prune tree use nuclear topology

#!/usr/bin/env bash
set -euo pipefail

MASTER_TRE="/mnt/spareHD_2/oxphos_gene_tree/species_astral.tre"  # 固定拓扑
CF_DIR="/mnt/spareHD_2/mt_gene_tree/counts"                      # mtDNA CF 目录
OUT_DIR="/mnt/spareHD_2/mt_gene_tree/pruned_trees"
THREADS=8

mkdir -p "$OUT_DIR"

# 提取 master tree 物种名
tr '(),:;' '\n' < "$MASTER_TRE" | grep -vE '^$|^[0-9.]+$' | sort -u > /tmp/master.tips

for CF in "$CF_DIR"/*.cf; do
    GENE=$(basename "$CF" .cf)
    echo "🌿 处理 $GENE ..."

    # 从 CF 提取物种名
    awk 'NR==2 && $1=="CHROM"{for(i=3;i<=NF;i++) print $i}' "$CF" | sort -u > /tmp/cf.taxa

    # 取交集
    comm -12 /tmp/master.tips /tmp/cf.taxa > /tmp/keep.taxa

    NUM_TAXA=$(wc -l < /tmp/keep.taxa)
    if (( NUM_TAXA < 4 )); then
        echo "⚠️  $GENE 物种数太少 ($NUM_TAXA)，跳过"
        continue
    fi

    # 固定 topology 重新估 branch length
    iqtree2 -s "$CF" \
            -m GTR+P \
            -g "$MASTER_TRE" \
            -nt "$THREADS" \
            --safe \
            -pre "$OUT_DIR/${GENE}_fixed" \
            -quiet \
    || { echo "❌ $GENE 运行失败，跳过"; continue; }

    echo "✅ $GENE 完成"
done

echo -e "\n🎯 所有 mtDNA 基因树已剪枝并重新估分支长度，结果在 $OUT_DIR"






MT_LIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
NUC_DIR=/mnt/spareHD_2/nuclear_with_readgroups_subset
OUT_LIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt

awk -v d="$NUC_DIR" '
  # 每行形如 .../10_THE_mtDNA.bam → 取 10_THE
  {
    n = match($0, /([0-9]+_[A-Z]+)/, a)
    sid = a[1]                               # 10_THE
    print d "/" sid "_subset.bam"
  }
' "$MT_LIST" > "$OUT_LIST"


#!/usr/bin/env bash
set -euo pipefail                      # 出错即停，未定义变量即报错

#####################  路径配置  #####################
REF=/work/cyu/stickleback_nuclear_only.fa.gz                # 参考基因组（已 bgzip+faidx）
MT_BAMLIST=/work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt
NUC_DIR=/mnt/spareHD_2/nuclear_with_readgroups_subset       # *_subset.bam
BEDDIR=/mnt/spareHD_2/oxphos_gene_tree/beds                 # 每基因 .bed
OUT=/mnt/spareHD_2/oxphos_gene_tree                         # 输出目录
THREADS=8                                                   # 当前 samtools 版本不支持 -@，仅留作记录
############################################################

mkdir -p "$OUT"/{mpileup,beds}

#####################  1. 生成核 bamlist，保持与 mtDNA 顺序一致  #####################
BAMLIST_NUC=$OUT/bamlist_nuclear.txt
awk -v d="$NUC_DIR" '
  {
    match($0, /([0-9]+_[A-Z]+)/, a);        # 提取样本 ID（如 10_THE）
    file=d"/"a[1]"_subset.bam";
    if (system("[ -f "file" ]")==0) print file;    # 核 BAM 存在才写
    else {
        printf("⚠️  Warning: %s 不存在，已跳过\n", file) > "/dev/stderr"
    }
  }' "$MT_BAMLIST" > "$BAMLIST_NUC"

echo "📄  核 bamlist 写入 $(wc -l < "$BAMLIST_NUC") 条路径 → $BAMLIST_NUC"

#####################  2. 逐基因 mpileup（参数与示例保持一致）  #####################
for BED in "$BEDDIR"/*.bed; do
    GENE=$(basename "$BED" .bed)
    echo "🧬  mpileup  $GENE"

    samtools mpileup \
        -B \
        -f "$REF" \
        -b "$BAMLIST_NUC" \
        -q 30 \
        -Q 30 \
        -d 5000 \
        -l "$BED" \
      | gzip > "$OUT/mpileup/${GENE}.mpileup.gz"
done

echo -e "\n🎉  mpileup.gz 文件全部写入：$OUT/mpileup/"

cd /mnt/spareHD_2/oxphos_gene_tree/mpileup
gunzip *.mpileup.gz           # 串行
# 或并行
ls *.mpileup.gz | xargs -n1 -P8 gunzip




#mileup to sync
MP_DIR=/mnt/spareHD_2/oxphos_gene_tree/mpileup
SYNC_DIR=/mnt/spareHD_2/oxphos_gene_tree/sync
mkdir -p "$SYNC_DIR"

for MP in "$MP_DIR"/*.mpileup; do
  GENE=$(basename "$MP" .mpileup)
  perl mpileup2sync.pl \
       --input "$MP" \
       --output "$SYNC_DIR/${GENE}.sync" \
       --fastq-type sanger \
       --min-qual 30
done

#create cf files then iqtree
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt
# 把路径剪成样本 ID，例如 10_THE
POPS=($(awk -F'/' '{sub(/_subset\.bam$/,"",$NF); print $NF}' "$BAMLIST"))
echo "${#POPS[@]} pops: ${POPS[@]}"

#!/usr/bin/env python3
import sys, pathlib

sync, cf, *pops = sys.argv[1:]
with open(sync) as f, open(cf, "w") as o:
    lines=[l.split() for l in f]
    o.write(f"COUNTSFILE NPOP {len(pops)} NSITES {len(lines)}\n")
    o.write("CHROM  POS  " + "  ".join(pops) + "\n")
    for chrom,pos,ref,*cols in lines:
        row=[]
        for c in cols:                       # A:C:G:T:N:Indel
            a,cg,g,t,_,_ = map(int,c.split(':'))
            row.append(f"{a},{cg},{g},{t}")
        o.write(f"{chrom}  {pos}  " + "  ".join(row) + "\n")


#################### 0. 生成 POPS 数组 ####################
BAMLIST=/mnt/spareHD_2/oxphos_gene_tree/bamlist_nuclear.txt   # ← 核 bamlist
# 从路径中抽出样本 ID，顺序与 bamlist 完全一致
POPS=($(awk -F'/' '{sub(/_subset\.bam$/,"",$NF); print $NF}' "$BAMLIST"))

echo "检测到 ${#POPS[@]} 个种群："
echo "${POPS[@]}"
# 确认输出应为：10_THE 11_JOE … 9_SWA  共 27 个

#################### 1. sync → cf 批量转换 ####################
SYNC_DIR=/mnt/spareHD_2/oxphos_gene_tree/sync
CF_DIR=/mnt/spareHD_2/oxphos_gene_tree/counts
mkdir -p "$CF_DIR"

for S in "$SYNC_DIR"/*.sync; do
  [[ -s "$S" ]] || { echo "⚠  跳过空文件 $S"; continue; }
  GENE=$(basename "$S" .sync)

  python /path/to/sync2cf.py  \
         "$S"  "$CF_DIR/${GENE}.cf"  "${POPS[@]}"
done
echo "✅ counts(.cf) 写入 $CF_DIR"



#iqtree
#!/usr/bin/env bash
set -euo pipefail

# -----------  路径 ------------
CF_DIR=/mnt/spareHD_2/oxphos_gene_tree/counts   # 你的 .cf 文件目录
TREE_DIR=/mnt/spareHD_2/oxphos_gene_tree/trees  # 输出目录
mkdir -p "$TREE_DIR"

THREADS=AUTO      # AUTO = IQ-TREE 自动检测；也可写 16、32 等
BOOT=1000         # Ultrafast bootstrap 轮数
ALRT=1000         # SH-aLRT 轮数

# -----------  循环跑 -----------
for CF in "$CF_DIR"/*.cf; do
  GENE=$(basename "$CF" .cf)
  echo "🌳  IQ-Tree  $GENE  ($(date +%T))"

  iqtree2 -s "$CF" \
          -m GTR+P \
          -nt "$THREADS" \
          -B "$BOOT" \
          -alrt "$ALRT" \
          -pre "$TREE_DIR/$GENE" \
          -quiet
done

echo -e "\n✅  所有基因树完成！树文件在：$TREE_DIR/*.treefile"

#构建master树 用nuclear oxpho 82genetree
java -Xmx8g -jar astral.5.7.8.jar \
  -i /mnt/spareHD_2/oxphos_gene_tree/genes_astral.tre \
  -o /mnt/spareHD_2/oxphos_gene_tree/species_astral.tre \
  2> /mnt/spareHD_2/oxphos_gene_tree/astral.log
astral.5.7.8.jar 
cat /mnt/spareHD_2/oxphos_gene_tree/species_astral.tre
(10_THE,(16_AMO,(((9_SWA,(11_JOE,12_BEA)0.49:0.052704063490568435)0.86:0.12852164098344246,((13_MUC,(22_FRED,24_PACH)1:0.7981770630522537)0.74:0.09167667908034977,((27_LB,(17_SAY,(28_CH,(25_RS,26_SC)1:0.4418327522790392)1:1.0091776080159818)0.68:0.16080153569716776)0.98:0.22450967855654755,((4_SL,(8_WK,7_WT)0.92:0.15588829972579915)0.44:0.02734415112952233,((5_TL,3_SR)0.64:0.06916681982473395,(2_LG,(1_FG,6_WB)0.98:0.20763936477824518)0.51:0.03889609052423365)0.49:0.04632609721427273)0.83:0.12022862571625097)0.5:0.03645182279797124)0.5:0.03708014865417043)0.44:0.022098788242902498,((14_PYE,19_ROB)0.66:0.07594115323538288,(23_LAW,((18_GOS,21_ECHO)0.97:0.2709576295105863,20_BOOT)1:0.8748478121554343)1:0.5341491814983622)0.38:0.007488021780721204)0.49:0.03425810992000614):0.0);


#using master tree prune gene tree
#!/usr/bin/env bash
set -euo pipefail

MASTER_TRE="/mnt/spareHD_2/oxphos_gene_tree/species_astral.tre"
CF_DIR="/mnt/spareHD_2/oxphos_gene_tree/counts"
OUT_DIR="/mnt/spareHD_2/oxphos_gene_tree/pruned_trees"
THREADS=8

mkdir -p "$OUT_DIR"

# 提取 master tree 物种名（去掉分支长度和支持值）
tr '(),:;' '\n' < "$MASTER_TRE" | grep -vE '^$|^[0-9.]+$' | sort -u > /tmp/master.tips

for CF in "$CF_DIR"/*.cf; do
    GENE=$(basename "$CF" .cf)
    echo "🌿 处理 $GENE ..."

    # 从 .cf 文件第2行提取物种名
    awk 'NR==2 && $1=="CHROM"{for(i=3;i<=NF;i++) print $i}' "$CF" | sort -u > /tmp/cf.taxa

    # 取交集
    comm -12 /tmp/master.tips /tmp/cf.taxa > /tmp/keep.taxa

    NUM_TAXA=$(wc -l < /tmp/keep.taxa)
    if (( NUM_TAXA < 4 )); then
        echo "⚠️  $GENE 物种数太少 ($NUM_TAXA)，跳过"
        continue
    fi

    # 用 IQ-TREE 固定 topology 重新估分支长度
    iqtree2 -s "$CF" \
            -m GTR+P \
            -g "$MASTER_TRE" \
            -nt "$THREADS" \
            --safe \
            -pre "$OUT_DIR/${GENE}_fixed" \
            -quiet \
    || { echo "❌ $GENE 运行失败，跳过"; continue; }

    echo "✅ $GENE 完成"
done

echo -e "\n🎯 所有基因树已剪枝并重新估分支长度，结果在 $OUT_DIR"

#add gene name to the tre file and combine treefiles
cd /mnt/spareHD_2/oxphos_gene_tree/pruned_trees

for f in $(ls *_fixed.treefile | sort); do
    gene=${f%%_*}   # 文件名前缀为 gene 名
    echo "[$gene]"  # 这是注释行
    cat "$f"
done > /mnt/spareHD_2/oxphos_gene_tree/genes_astral_named.tre

treefile = "/users/changyueyu/desktop/genes_astral_named.tre"

outputfile = "/users/changyueyu/desktop/out.RDS"





#!/usr/bin/env bash
set -euo pipefail

MASTER_TRE="/mnt/spareHD_2/oxphos_gene_tree/species_astral.tre"
CF_DIR="/mnt/spareHD_2/mt_gene_tree/counts_top2"
OUT_DIR="/mnt/spareHD_2/mt_gene_tree/pruned_trees_top2"
THREADS=8

mkdir -p "$OUT_DIR"

# 提取 master tree 物种名
tr '(),:;' '\n' < "$MASTER_TRE" | grep -vE '^$|^[0-9.]+$' | sort -u > /tmp/master.tips

for CF in "$CF_DIR"/*.cf; do
    GENE=$(basename "$CF" .cf)
    echo "🌿 处理 $GENE ..."

    # 从 .cf 文件头提取物种名
    awk 'NR==2 && $1=="CHROM"{for(i=3;i<=NF;i++) print $i}' "$CF" | sort -u > /tmp/cf.taxa

    # 取交集
    comm -12 /tmp/master.tips /tmp/cf.taxa > /tmp/keep.taxa
    NUM_TAXA=$(wc -l < /tmp/keep.taxa)

    if (( NUM_TAXA < 4 )); then
        echo "⚠️  $GENE 物种数太少 ($NUM_TAXA)，跳过"
        continue
    fi

    # 固定拓扑，PoMo 模型，重新估 branch length
    iqtree2 -s "$CF" \
            -m GTR+P \
            -g "$MASTER_TRE" \
            -nt "$THREADS" \
            --safe \
            -pre "$OUT_DIR/${GENE}_fixed" \
            -quiet \
    || { echo "❌ $GENE 运行失败，跳过"; continue; }

    echo "✅ $GENE 完成"
done

echo -e "\n🎯 所有基因树已剪枝并重新估分支长度，结果在 $OUT_DIR"



#!/usr/bin/env bash
set -euo pipefail

MASTER_TRE="/mnt/spareHD_2/oxphos_gene_tree/species_astral.tre"
CF_DIR="/mnt/spareHD_2/mt_gene_tree/counts"
OUT_DIR="/mnt/spareHD_2/mt_gene_tree/pruned_trees"
THREADS=8

mkdir -p "$OUT_DIR"

# 提取 master tree 物种名
tr '(),:;' '\n' < "$MASTER_TRE" | grep -vE '^$|^[0-9.]+$' | sort -u > /tmp/master.tips

for CF in "$CF_DIR"/*.cf; do
    GENE=$(basename "$CF" .cf)
    echo "🌿 处理 $GENE ..."

    # 从 .cf 文件头提取物种名
    awk 'NR==2 && $1=="CHROM"{for(i=3;i<=NF;i++) print $i}' "$CF" | sort -u > /tmp/cf.taxa

    # 取交集
    comm -12 /tmp/master.tips /tmp/cf.taxa > /tmp/keep.taxa
    NUM_TAXA=$(wc -l < /tmp/keep.taxa)

    if (( NUM_TAXA < 4 )); then
        echo "⚠️  $GENE 物种数太少 ($NUM_TAXA)，跳过"
        continue
    fi

    # 固定拓扑，PoMo 模型，重新估 branch length
    iqtree2 -s "$CF" \
            -m HKY+P \
            -g "$MASTER_TRE" \
            -nt "$THREADS" \
            --safe \
            -pre "$OUT_DIR/${GENE}_fixed" \
            -quiet \
    || { echo "❌ $GENE 运行失败，跳过"; continue; }

    echo "✅ $GENE 完成"
done

echo -e "\n🎯 所有基因树已剪枝并重新估分支长度，结果在 $OUT_DIR"



#!/usr/bin/env bash
set -euo pipefail

MASTER_TRE="/mnt/spareHD_2/oxphos_gene_tree/species_astral.tre"
CF_DIR="/mnt/spareHD_2/mt_gene_tree/counts"
OUT_DIR="/mnt/spareHD_2/mt_gene_tree/pruned_trees"
THREADS=8

mkdir -p "$OUT_DIR"

# 提取 master tree 物种名
tr '(),:;' '\n' < "$MASTER_TRE" | grep -vE '^$|^[0-9.]+$' | sort -u > /tmp/master.tips

for CF in "$CF_DIR"/*.cf; do
    GENE=$(basename "$CF" .cf)
    echo "🌿 处理 $GENE ..."

    # 从 .cf 文件头提取物种名
    awk 'NR==2 && $1=="CHROM"{for(i=3;i<=NF;i++) print $i}' "$CF" | sort -u > /tmp/cf.taxa

    # 取交集
    comm -12 /tmp/master.tips /tmp/cf.taxa > /tmp/keep.taxa
    NUM_TAXA=$(wc -l < /tmp/keep.taxa)

    if (( NUM_TAXA < 4 )); then
        echo "⚠️  $GENE 物种数太少 ($NUM_TAXA)，跳过"
        continue
    fi

    # 固定拓扑，PoMo 模型，重新估 branch length
    iqtree2 -s "$CF" \
            -m GTR+P \
            -g "$MASTER_TRE" \
            -nt "$THREADS" \
            -blmin 1e-12 -blmax 100 \
            --pomo-min-sample 1 --pomo-min-freq 0 \
            -pre "$OUT_DIR/${GENE}_fixed" \
            -quiet \
    || { echo "❌ $GENE 运行失败，跳过"; continue; }

    echo "✅ $GENE 完成"
done

echo -e "\n🎯 所有基因树已剪枝并重新估分支长度，结果在 $OUT_DIR"


#using master tree prune gene tree
#!/usr/bin/env bash
set -euo pipefail

MASTER_TRE="/mnt/spareHD_2/oxphos_gene_tree/species_astral.tre"
CF_DIR="/mnt/spareHD_2/mt_gene_tree/counts"
OUT_DIR="/mnt/spareHD_2/mt_gene_tree/pruned_trees"
THREADS=8

mkdir -p "$OUT_DIR"

# 提取 master tree 物种名（去掉分支长度和支持值）
tr '(),:;' '\n' < "$MASTER_TRE" | grep -vE '^$|^[0-9.]+$' | sort -u > /tmp/master.tips

for CF in "$CF_DIR"/*.cf; do
    GENE=$(basename "$CF" .cf)
    echo "🌿 处理 $GENE ..."

    # 从 .cf 文件第2行提取物种名
    awk 'NR==2 && $1=="CHROM"{for(i=3;i<=NF;i++) print $i}' "$CF" | sort -u > /tmp/cf.taxa

    # 取交集
    comm -12 /tmp/master.tips /tmp/cf.taxa > /tmp/keep.taxa

    NUM_TAXA=$(wc -l < /tmp/keep.taxa)
    if (( NUM_TAXA < 4 )); then
        echo "⚠️  $GENE 物种数太少 ($NUM_TAXA)，跳过"
        continue
    fi

    # 用 IQ-TREE 固定 topology 重新估分支长度
    iqtree2 -s "$CF" \
            -m GTR+P \
            -g "$MASTER_TRE" \
            -nt "$THREADS" \
            --safe \
            -pre "$OUT_DIR/${GENE}_fixed" \
            -quiet \
    || { echo "❌ $GENE 运行失败，跳过"; continue; }

    echo "✅ $GENE 完成"
done

echo -e "\n🎯 所有基因树已剪枝并重新估分支长度，结果在 $OUT_DIR"





1) 给每个目录做“带基因名”的 .tre
核基因（你基本已有）：

bash
Copy
Edit
cd /mnt/spareHD_2/oxphos_gene_tree/pruned_trees

for f in $(ls *_fixed.treefile | sort); do
    gene=${f%%_*}
    printf '[%s]\n' "$gene"
    cat "$f"
    printf '\n'
done > /mnt/spareHD_2/oxphos_gene_tree/genes_astral_named.tre
线粒体基因（top2 目录）：

bash
Copy
Edit
cd /mnt/spareHD_2/mt_gene_tree/pruned_trees_top2

for f in $(ls *_fixed.treefile | sort); do
    gene=${f%%_*}          # 文件名前缀作为基因名（ATP6、ND1…）
    printf '[%s]\n' "$gene"
    cat "$f"
    printf '\n'
done > /mnt/spareHD_2/mt_gene_tree/mt_genes_named.tre
快速检查各自包含的树数（= 基因数）：

bash
Copy
Edit
grep -c '^\[' /mnt/spareHD_2/oxphos_gene_tree/genes_astral_named.tre
grep -c '^\[' /mnt/spareHD_2/mt_gene_tree/mt_genes_named.tre
2) 合并核 + 线粒体为一个大 .tre
bash
Copy
Edit
cat \
  /mnt/spareHD_2/oxphos_gene_tree/genes_astral_named.tre \
  /mnt/spareHD_2/mt_gene_tree/mt_genes_named.tre \
  > /mnt/spareHD_2/all_genes_named.tre

# 再数一下总共有多少棵树（基因）
grep -c '^\[' /mnt/spareHD_2/all_genes_named.tre