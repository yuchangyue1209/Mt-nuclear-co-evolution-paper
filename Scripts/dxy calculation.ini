#dxy calculation
# nuclear mileup merge BAM files (in the order of the file paths in BAMlist.txt) in a MPILEUP file only retaining nucleotides with BQ >20 and reads with MQ > 20
cd /mnt/spareHD_2/marked_duplicates/
samtools mpileup -B \
    -f /work/cyu/stickleback_nuclear_only.fa \
    -b bamlist.txt \
    -q 30 \
    -Q 30 \
    -d 5000 \
    | gzip > nuclear.mpileup.gz

gunzip /mnt/spareHD_2/marked_duplicates/nuclear.mpileup.gz

/mnt/spareHD_2/nuclear_marked_duplicates/nuclear.mpileup

perl mpileup2sync.pl \
    --input /mnt/spareHD_2/nuclear_marked_duplicates/crispr.mpileup \
    --output /mnt/spareHD_2/nuclear_marked_duplicates/nuclear.sync \
    --fastq-type sanger \
    --min-qual 20

#mt mileup
1.#create bam.list
ls -1 /work/cyu/poolseq/PPalign_output/mtDNA_bam/*.bam > /work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt

# merge BAM files (in the order of the file paths in BAMlist.txt) in a MPILEUP file only retaining nucleotides with BQ >20 and reads with MQ > 20
samtools mpileup -B \
    -f /work/cyu/sequence.fasta \
    -b bamlist.txt \
    -q 30 \
    -Q 30 \
    -d 5000 \
    | gzip > fish.mpileup.gz

perl mpileup2sync.pl \
    --input /work/cyu/poolseq/PPalign_output/mtDNA_bam/fish.mpileup \
    --output /work/cyu/poolseq/PPalign_output/mtDNA_bam/fish.sync \
    --fastq-type sanger \
    --min-qual 20


#bed files
#!/bin/bash

# === 输入文件路径 ===
SYNC="/mnt/spareHD_2/nuclear_marked_duplicates/nuclear.sync"
BED="/work/cyu/nuOXPHOS_genes_with_complex_core.bed"
OUTDIR="/mnt/spareHD_2/nuclear/bed"
mkdir -p "$OUTDIR"

# === Step 1: 生成 BED 格式的 sync 文件 ===
echo "📦 Generating nuclear.sync.bed..."
awk '{print $1, $2, $2+1, $0}' OFS='\t' "$SYNC" > "$OUTDIR/nuclear.sync.bed"

# === Step 2: 生成子集 BED 文件 ===
echo "🔧 Splitting BED annotations..."
awk '$8 == "core"' "$BED" > "$OUTDIR/core.bed"
awk '$8 == "noncore"' "$BED" > "$OUTDIR/noncore.bed"
awk '$9 == "contact"' "$BED" > "$OUTDIR/contact.bed"
awk '$9 == "noncontact"' "$BED" > "$OUTDIR/noncontact.bed"

# 分别提取 complex I-V
for c in I II III IV V; do
    awk -v C="$c" '$7 == C' "$BED" > "$OUTDIR/complex${c}.bed"
done

# === Step 3: 提取交集 SNPs ===
echo "🧬 Extracting SNPs by category..."

bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/core.bed" > "$OUTDIR/core.sync"
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/noncore.bed" > "$OUTDIR/noncore.sync"
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/contact.bed" > "$OUTDIR/contact.sync"
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/noncontact.bed" > "$OUTDIR/noncontact.sync"

for c in I II III IV V; do
    echo "🔍 Extracting SNPs for Complex $c..."
    bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$OUTDIR/complex${c}.bed" > "$OUTDIR/complex${c}.sync"
done

# 所有 nuOXPHOS 区域 SNP
bedtools intersect -a "$OUTDIR/nuclear.sync.bed" -b "$BED" > "$OUTDIR/all_nuOXPHOS.sync"

echo "✅ All output files saved to $OUTDIR"


#去掉前三列
#!/bin/bash

# 设置工作目录
WORKDIR="/mnt/spareHD_2/nuclear/bed"
cd "$WORKDIR" || exit 1

echo "🔁 Processing *.sync files in: $WORKDIR"

# 遍历所有 .sync 文件（排除 *_fixed.sync）
for FILE in *.sync; do
    # 跳过已处理的文件
    if [[ "$FILE" == *_fixed.sync ]]; then
        continue
    fi

    BASENAME="${FILE%.sync}"
    FIXED="${BASENAME}_fixed.sync"

    echo "📂 Converting $FILE -> $FIXED"
    cut -f4- "$FILE" > "$FIXED"
done

echo "✅ Done. All *_fixed.sync files are created."




#!/usr/bin/env Rscript
# calc_dxy.R

# 安装/加载依赖包
if (!requireNamespace("data.table", quietly=TRUE)) install.packages("data.table")
if (!requireNamespace("parallel", quietly=TRUE)) install.packages("parallel")
library(data.table)
library(parallel)

# 1. 解析 .sync 文件，生成等位基因频率矩阵
# 输入：路径，群体数
read_sync_freq <- function(sync_path, npops=27) {
  # 读取 sync（跳过前三列：chr, pos, ref）
  cols <- c("chr","pos","ref", paste0("pop",1:npops))
  sync <- fread(sync_path, header=FALSE, col.names=cols, showProgress=FALSE)
  
  # 只取 counts 列
  pop_cols <- cols[4:length(cols)]
  
  # 解析函数：取第一个碱基（ref）频率
  parse_freq <- function(x) {
    cnt <- as.integer(strsplit(x,":")[[1]][1:4])
    tot <- sum(cnt)
    if (tot==0) return(NA_real_)
    cnt[1]/tot
  }
  
  # 并行化解析：每一列一个进程
  freq_mat <- mclapply(pop_cols, function(col) {
    vapply(sync[[col]], parse_freq, numeric(1))
  }, mc.cores=detectCores())
  
  freq <- do.call(cbind, freq_mat)
  colnames(freq) <- pop_cols
  rownames(freq) <- paste0(sync$chr, ":", sync$pos)
  return(freq)
}

# 2. 计算成对 dXY
calc_pairwise_dxy <- function(freq_mat) {
  pops <- colnames(freq_mat)
  n <- ncol(freq_mat)
  # result 矩阵
  m <- matrix(NA, n, n, dimnames=list(pops, pops))
  
  # 单个位点 dxy
  calc_site <- function(p, q) p*(1-q) + (1-p)*q
  
  for (i in seq_len(n)) {
    for (j in i:n) {
      p <- freq_mat[,i]; q <- freq_mat[,j]
      dsite <- calc_site(p, q)
      m[i,j] <- m[j,i] <- mean(dsite, na.rm=TRUE)
    }
  }
  return(m)
}

# 3. 主流程
args <- commandArgs(trailingOnly=TRUE)
if (length(args)!=2) {
  stop("Usage: Rscript calc_dxy.R <nuclear.sync> <mt.sync>")
}
nuc_sync <- args[1]
mt_sync  <- args[2]

cat("Reading nuclear sync...\n")
freq_nu <- read_sync_freq(nuc_sync)
cat("Computing nuclear dXY matrix...\n")
dxy_nu  <- calc_pairwise_dxy(freq_nu)

cat("Reading mt sync...\n")
freq_mt <- read_sync_freq(mt_sync)
cat("Computing mt dXY matrix...\n")
dxy_mt  <- calc_pairwise_dxy(freq_mt)

# 4. 保存结果
write.csv(dxy_nu, "dxy_nuclear_matrix.csv", quote=FALSE)
write.csv(dxy_mt,  "dxy_mt_matrix.csv",     quote=FALSE)

cat("Done! Results in dxy_nuclear_matrix.csv and dxy_mt_matrix.csv\n")



Rscript calc_dxy.R /mnt/spareHD_2/nuclear/bed/all_nuOXPHOS_fixed.sync /work/cyu/poolseq/PPalign_output/ann/fish_pcg_fixed.sync




#heatmap
#!/usr/bin/env Rscript

pkgs <- c("data.table", "pheatmap")
for (pkg in pkgs) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, repos = "https://cloud.r-project.org")
  }
}
library(data.table)
library(pheatmap)

args <- commandArgs(trailingOnly = TRUE)
if (length(args) != 2) {
  stop("Usage: Rscript dxy_heatmap_plot.R <dxy_matrix.csv> <bamlist.txt>")
}
dxy_file <- args[1]
bamlist_file <- args[2]

# 读取 dXY matrix
dxy <- fread(dxy_file, data.table = FALSE)
rownames(dxy) <- dxy[[1]]
dxy <- dxy[,-1]

# 读取 bamlist，提取种群名（大写）
bamlist <- fread(bamlist_file, header = FALSE)[[1]]
sample_names <- basename(bamlist)
pops <- toupper(gsub(".*?_([A-Za-z]+)_.*", "\\1", sample_names))

if (length(pops) != ncol(dxy)) stop("Mismatch between BAM list and dXY matrix columns")

colnames(dxy) <- pops
rownames(dxy) <- pops

# 自定义蓝色渐变色图（浅蓝白到深蓝）
my_colors <- colorRampPalette(c("#eaf3fa", "#2b7bba"))(100)

# 保存为 PDF 文件
pdf("dxy_mt_matrix_heatmap.pdf", width = 8, height = 8)
pheatmap(dxy,
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         clustering_method = "average",
         color = my_colors,
         main = "Pairwise dXY Heatmap",
         angle_col = 45,
         fontsize = 10)
dev.off()

cat("✅ Heatmap saved as dxy_mt_matrix_heatmap.pdf\n")
Rscript dxy_heatmap_plot.R dxy_mt_matrix.csv /work/cyu/poolseq/PPalign_output/mtDNA_bam/bamlist.txt

