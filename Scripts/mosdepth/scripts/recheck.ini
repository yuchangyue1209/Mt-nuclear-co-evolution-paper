OUTDIR="/work/cyu/oxphos_from_ref_no_biomart/06_igv"
QCOUT="$OUTDIR/cnv_qc_backfilled_nuclear"
STATUS="$OUTDIR/OXPHOS_merged_status.backfilled.withCN.tsv"
COMB_PARTS="$QCOUT/parts.present+putative.4col.bed"   # 你合并的 present+putative
mkdir -p "$QCOUT"

# A. 提取 parts 里出现过的“名字前缀”（去掉 |exonN / |span），小写去重
cut -f4 "$COMB_PARTS" \
| awk -F'\\|' '{print tolower($1)}' \
| sort -u > "$QCOUT/names_in_parts.list"

# B. 从状态表抽 “present=yes” 的所有别名（分号拆开），小写去重
awk -F'\t' 'NR==1{
  for(i=1;i<=NF;i++){h[$i]=i}; next
}
($h["present_in_fish"]=="yes" && $h["stickleback_name"]!=""){
  n=split($(h["stickleback_name"]), a, /[;,\t ]+/)
  for(j=1;j<=n;j++){s=a[j]; gsub(/^ +| +$/,"",s); if(s!="") print tolower(s)}
}' "$STATUS" | sort -u > "$QCOUT/aliases_present_yes.list"

echo "parts里名字数：$(wc -l < "$QCOUT/names_in_parts.list")"
echo "present=yes 的别名数：$(wc -l < "$QCOUT/aliases_present_yes.list")"

# C. 真正“命中 parts”的别名 & 没命中的别名
grep -Fiwf "$QCOUT/names_in_parts.list" "$QCOUT/aliases_present_yes.list" > "$QCOUT/aliases_hit_in_parts.list" || true
comm -23 "$QCOUT/aliases_present_yes.list" "$QCOUT/names_in_parts.list" > "$QCOUT/aliases_missing_from_parts.list" || true

echo "✅ 命中 parts 的别名条数：$(wc -l < "$QCOUT/aliases_hit_in_parts.list")"
echo "❗未在 parts 出现的别名条数：$(wc -l < "$QCOUT/aliases_missing_from_parts.list")"


# 做一个 gene 粒度的报告：对每个 human_symbol，给出别名命中与否
awk -F'\t' 'NR==1{for(i=1;i<=NF;i++)h[$i]=i; print "human_symbol\taliases\tmatched\tunmatched\tinfo"; next}
{
  if($(h["present_in_fish"])!="yes"){next}
  split($(h["stickleback_name"]), a, /[;,\t ]+/)
  ali=""; mat=""; um=""
  for(j=1;j<=length(a);j++){
    s=a[j]; gsub(/^ +| +$/,"",s); if(s=="") continue
    lo=tolower(s)
    if(system("grep -Fwxq \""lo"\" '"$QCOUT/names_in_parts.list"'")==0){mat=(mat?mat";":mat) s}
    else {um=(um?um";":um) s}
    ali=(ali?ali";":ali) s
  }
  info=$(h["evidence"])
  print $(h["human_symbol"]), ali, (mat?mat:"-"), (um?um:"-"), info
}' OFS='\t' "$STATUS" > "$QCOUT/present_yes.alias_match_report.tsv"

column -t -s $'\t' "$QCOUT/present_yes.alias_match_report.tsv" | sed -n '1,30p'


# 重新以 COMB_PARTS 为 by 区间跑所有池
POOL_INFO="/work/cyu/poolseq/pool_info.txt"
INPUT_DIR="/mnt/spareHD_2/nuclear_with_readgroups"

tail -n +2 "$POOL_INFO" | awk '{print $1}' | while read -r SAMPLE; do
  BAM="${INPUT_DIR}/${SAMPLE}_rg.bam"
  [ -s "$BAM" ] || { echo "⚠️ 跳过 $SAMPLE（无 BAM）"; continue; }
  echo "-> mosdepth (COMB) on $SAMPLE"
  mosdepth -n -x -Q 1 \
    --by "$COMB_PARTS" \
    "$QCOUT/${SAMPLE}.COMB" \
    "$BAM"
done

# 然后用你之前的聚合脚本（生成 per-gene depth 和 CN 表）再跑一遍；
# 关键是：聚合时以 “name 的 | 左侧前缀” 作为 gene key，不要剥掉 _putative。


echo "✅ 命中 parts 的别名条数：$(wc -l < "$QCOUT/aliases_hit_in_parts.list")" echo "❗未在 parts 出现的别名条数：$(wc -l < "$QCOUT/aliases_missing_from_parts.list")" parts里名字数：120 present=yes 的别名数：149 ✅ 命中 parts 的别名条数：120 ❗未在 parts 出现的别名条数：29

#看清这 29 个到底是谁、属于哪几个基因
OUTDIR="/work/cyu/oxphos_from_ref_no_biomart/06_igv"
QCOUT="$OUTDIR/cnv_qc_backfilled_nuclear"
STATUS="$OUTDIR/OXPHOS_merged_status.backfilled.withCN.tsv"

echo "[Missing aliases] (all):"
sed -n '1,200p' "$QCOUT/aliases_missing_from_parts.list"

# 按别名反查它属于哪个 human_symbol + evidence
echo -e "alias\thuman_symbol\tevidence" > "$QCOUT/aliases_missing.annot.tsv"
while read -r a; do
  awk -F'\t' -v A="$a" '
    BEGIN{IGNORECASE=1}
    NR==1{for(i=1;i<=NF;i++) h[$i]=i; next}
    ($h["present_in_fish"]=="yes" && $h["stickleback_name"]!="") {
      s=tolower($(h["stickleback_name"]))
      gsub(/[ ,]+/,";",s)
      n=split(s,arr,";")
      ok=0
      for(j=1;j<=n;j++){ if(arr[j]==tolower(A)) ok=1 }
      if(ok){ print A "\t" $(h["human_symbol"]) "\t" $(h["evidence"]); exit }
    }' "$STATUS" >> "$QCOUT/aliases_missing.annot.tsv"
done < "$QCOUT/aliases_missing_from_parts.list"

column -t -s $'\t' "$QCOUT/aliases_missing.annot.tsv" | sed -n '1,40p'

#py
#!/usr/bin/env python3
import sys, csv, re

if len(sys.argv)<3:
    sys.stderr.write("Usage: join_cnv_into_status_by_alias.py STATUS.tsv CN_table.tsv > OUT.tsv\n")
    sys.exit(1)

status_p, cn_p = sys.argv[1], sys.argv[2]

def norm(s):
    s = s.strip().lower()
    s = re.sub(r'\|exon\d+$', '', s)
    s = re.sub(r'\|span$', '', s)
    s = re.sub(r'\.t\d+$', '', s)
    s = s.replace('ensgact', 'ensgacg')  # 视为等价
    return s

# 读 CN 表（key=规范化后的名字）
cn_rows = {}
with open(cn_p) as f:
    r = csv.DictReader(f, delimiter='\t')
    cn_hdr = r.fieldnames
    for row in r:
        key = norm(row['gene'])
        cn_rows[key] = row

# 读状态表并写出
with open(status_p) as f:
    r = csv.DictReader(f, delimiter='\t')
    hdr = r.fieldnames
    # 确保 summary 列存在（没有就补空）
    for extra in ['CN_min','CN_max','N_outlier','outlier_pools']:
        if extra not in hdr: hdr.append(extra)
    w = csv.DictWriter(sys.stdout, delimiter='\t', fieldnames=hdr)
    w.writeheader()

    for row in r:
        present = row.get('present_in_fish','').strip().lower() == 'yes'
        aliases = row.get('stickleback_name','').strip()
        found = None
        if present and aliases:
            # 多别名尝试匹配（分号/逗号/空格都当分隔）
            for a in re.split(r'[;,\s]+', aliases):
                if not a: continue
                k = norm(a)
                if k in cn_rows:
                    found = cn_rows[k]
                    break
        # 写回 summary 列
        if found:
            row['CN_min'] = found.get('CN_min','')
            row['CN_max'] = found.get('CN_max','')
            row['N_outlier'] = found.get('N_outlier','')
            row['outlier_pools'] = found.get('outlier_pools','')
        else:
            # 保留为空（表示 present 但当前别名找不到 CN——可能确实没有区间，或 alias 尚未对齐）
            row.setdefault('CN_min','')
            row.setdefault('CN_max','')
            row.setdefault('N_outlier','')
            row.setdefault('outlier_pools','')
        w.writerow(row)


OUTDIR="/work/cyu/oxphos_from_ref_no_biomart/06_igv"
QCOUT="$OUTDIR/cnv_qc_backfilled_nuclear"
python "$OUTDIR/join_cnv_into_status_by_alias.py" \
  "$OUTDIR/OXPHOS_merged_status.backfilled.withCN.tsv" \
  "$QCOUT/oxphos_cnv.cnv_gene_cn.tsv" \
> "$OUTDIR/OXPHOS_merged_status.backfilled.withCN.v2.tsv"

echo "✅ 写入：$OUTDIR/OXPHOS_merged_status.backfilled.withCN.v2.tsv"
# 看看 present=yes 仍然没 CN_min 的条数
awk -F'\t' 'NR==1{for(i=1;i<=NF;i++)h[$i]=i;next}
($h["present_in_fish"]=="yes" && $h["CN_min"]==""){n++} END{print "present=yes 且仍无CN的条数：", n+0}' \
  "$OUTDIR/OXPHOS_merged_status.backfilled.withCN.v2.tsv"

仍然没对上的，逐一定位（是否真的没有区间）

对剩下没 CN 的基因（present=yes & CN_min==空），再核对是否的确没有出现在 COMB_PARTS 里（比如 putative 也还没加）：

# 列出 present=yes 但 CN 仍为空的 gene + 别名
awk -F'\t' 'NR==1{for(i=1;i<=NF;i++)h[$i]=i;next}
($h["present_in_fish"]=="yes" && $h["CN_min"]==""){
  print $h["human_symbol"]"\t"$h["stickleback_name"]"\t"$h["evidence"]
}' "$OUTDIR/OXPHOS_merged_status.backfilled.withCN.v2.tsv" \
| sed -n '1,50p'

# 也可把这些别名再和 COMB_PARTS 比一次（用与 A 相同的规范化逻辑，必要时我给你 Python 版）